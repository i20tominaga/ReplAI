{"version":3,"file":"viselect.mjs","sources":["../src/EventEmitter.ts","../src/utils/css.ts","../src/utils/events.ts","../src/utils/intersects.ts","../src/utils/selectAll.ts","../src/utils/constants.ts","../src/utils/deepAssign.ts","../src/utils/frames.ts","../src/index.ts"],"sourcesContent":["\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => any;\ntype EventMap = Record<string, AnyFunction>;\n\nexport class EventTarget<Events extends EventMap> {\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\n\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        const set = this._listeners.get(event) || new Set();\n        this._listeners.set(event, set);\n        set.add(cb as AnyFunction);\n        return this;\n    }\n\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        this._listeners.get(event)?.delete(cb as AnyFunction);\n        return this;\n    }\n\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): unknown {\n        let ok = true;\n        for (const cb of (this._listeners.get(event) || [])) {\n            ok = (cb(...data) !== false) && ok;\n        }\n\n        return ok;\n    }\n\n    public unbindAllListeners(): void {\n        this._listeners.clear();\n    }\n\n    // Let's also support on, off and emit like node\n    /* eslint-disable no-invalid-this */\n    public on = this.addEventListener;\n    public off = this.removeEventListener;\n    public emit = this.dispatchEvent;\n}\n","const unitify = (val: string | number, unit = 'px'): string => {\n    return typeof val === 'number' ? val + unit : val;\n};\n\n/**\n * Add css to a DOM-Element or returns the current\n * value of a property.\n *\n * @param el The Element.\n * @param attr The attribute or an object which holds css key-properties.\n * @param val The value for a single attribute.\n * @returns {*}\n */\nexport function css(\n    {style}: HTMLElement,\n    attr: Partial<Record<keyof CSSStyleDeclaration, string | number>> | string,\n    val?: string | number\n): void {\n    if (typeof attr === 'object') {\n\n        for (const [key, value] of Object.entries(attr)) {\n            value !== undefined && (style[key as any] = unitify(value));\n        }\n\n    } else if (val !== undefined) {\n        style[attr as any] = unitify(val);\n    }\n}\n\n\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype Method = 'addEventListener' | 'removeEventListener';\ntype AnyFunction = (...arg: any) => any;\n\nexport type EventBindingArgs = [\n        EventTarget | EventTarget[],\n        string | string[],\n    AnyFunction,\n    Record<string, unknown>?\n];\n\ninterface EventBinding {\n    (\n        elements: EventTarget | EventTarget[],\n        events: string | string[],\n        fn: AnyFunction,\n        options?: Record<string, unknown>\n    ): EventBindingArgs;\n}\n\n/* eslint-disable prefer-rest-params */\nfunction eventListener(method: Method): EventBinding {\n    return (\n        items: EventTarget | EventTarget[],\n        events: string | string[],\n        fn: AnyFunction, options = {}\n    ): EventBindingArgs => {\n\n        // Normalize array\n        if (items instanceof HTMLCollection || items instanceof NodeList) {\n            items = Array.from(items);\n        } else if (!Array.isArray(items)) {\n            items = [items];\n        }\n\n        if (!Array.isArray(events)) {\n            events = [events];\n        }\n\n        for (const el of items) {\n            for (const ev of events) {\n                el[method](ev, fn as EventListener, {capture: false, ...options});\n            }\n        }\n\n        return [items, events, fn, options];\n    };\n}\n\n/**\n * Add event(s) to element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const on = eventListener('addEventListener');\n\n/**\n * Remove event(s) from element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const off = eventListener('removeEventListener');\n\n/**\n * Simplifies a touch / mouse-event\n * @param evt\n */\nexport const simplifyEvent = (evt: any): {\n    target: HTMLElement;\n    x: number;\n    y: number;\n} => {\n    const { clientX, clientY, target } = (evt.touches && evt.touches[0] || evt);\n    return {x: clientX, y: clientY, target};\n};\n","export type Intersection = 'center' | 'cover' | 'touch'\n\n/**\n * Check if two DOM-Elements intersects each other.\n * @param a BoundingClientRect of the first element.\n * @param b BoundingClientRect of the second element.\n * @param mode Options are center, cover or touch.\n * @returns {boolean} If both elements intersects each other.\n */\nexport function intersects(a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean {\n    switch (mode) {\n        case 'center': {\n            const bxc = b.left + b.width / 2;\n            const byc = b.top + b.height / 2;\n\n            return bxc >= a.left &&\n                bxc <= a.right &&\n                byc >= a.top &&\n                byc <= a.bottom;\n        }\n        case 'cover': {\n            return b.left >= a.left &&\n                b.top >= a.top &&\n                b.right <= a.right &&\n                b.bottom <= a.bottom;\n        }\n        case 'touch': {\n            return a.right >= b.left &&\n                a.left <= b.right &&\n                a.bottom >= b.top &&\n                a.top <= b.bottom;\n        }\n    }\n}\n","export type SelectAllSelectors = readonly (string | Element)[] | string | Element;\n\n/**\n * Takes a selector (or array of selectors) and returns the matched nodes.\n * @param selector The selector or an Array of selectors.\n * @param doc\n * @returns {Array} Array of DOM-Nodes.\n */\nexport function selectAll(selector: SelectAllSelectors, doc: Document = document): Element[] {\n    const list = !Array.isArray(selector) ? [selector] : selector;\n    let nodes: Element[] = [];\n\n    for (let i = 0, l = list.length; i < l; i++) {\n        const item = list[i];\n\n        if (typeof item === 'string') {\n            /**\n             * We can't use the spread operator here as with large amounts of elements\n             * we'll get a \"Maximum call stack size exceeded\"-error.\n             */\n            nodes = nodes.concat(Array.from(doc.querySelectorAll(item)));\n        } else if (item instanceof Element) {\n            nodes.push(item);\n        }\n    }\n\n    return nodes;\n}\n","// Determines if the device's primary input supports touch\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\nexport const isTouchDevice = (): boolean => matchMedia('(hover: none), (pointer: coarse)').matches;\n\n// Determines if the browser is safari\nexport const isSafariBrowser = (): boolean => 'safari' in window;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nexport const deepAssign = <O extends Record<any, any>>(target: O, source: any): O => {\n    for (const [key, value] of Object.entries(target)) {\n        const sourceValue = source[key];\n\n        // Use the default value if there's no value specified\n        target[key as keyof O] = sourceValue === undefined ? target[key as keyof O] :\n\n            // Check if it's a nested object and merge if required\n            (typeof sourceValue === 'object' && typeof value === 'object' && value !== null && !Array.isArray(value)) ?\n                deepAssign(value as O, sourceValue as Partial<O>) : sourceValue;\n    }\n\n    return target;\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => void;\n\nexport interface Frames<F extends AnyFunction = AnyFunction> {\n    next(...args: Parameters<F>): void;\n\n    cancel(): void;\n}\n\nexport const frames = <F extends AnyFunction>(fn: F): Frames<F> => {\n    let previousArgs: Parameters<F>;\n    let frameId = -1;\n    let lock = false;\n\n    return {\n        next(...args: Parameters<F>): void {\n            previousArgs = args;\n\n            if (!lock) {\n                lock = true;\n                frameId = requestAnimationFrame(() => {\n                    fn(...previousArgs);\n                    lock = false;\n                });\n            }\n        },\n        cancel() {\n            cancelAnimationFrame(frameId);\n            lock = false;\n        }\n    };\n};\n","import {EventTarget} from './EventEmitter';\nimport type {AreaLocation, Coordinates, ScrollEvent, SelectionEvents, SelectionOptions, SelectionStore} from './types';\nimport {PartialSelectionOptions} from './types';\nimport {css, deepAssign, frames, Frames, intersects, isSafariBrowser, isTouchDevice, off, on, selectAll, SelectAllSelectors, simplifyEvent} from './utils';\n\n// Re-export types\nexport * from './types';\n\n// Some var shorting for better compression and readability\nconst {abs, max, min, ceil} = Math;\n\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\n    public static version = VERSION;\n\n    // Options\n    private readonly _options: SelectionOptions;\n\n    // Selection store\n    private _selection: SelectionStore = {\n        stored: [],\n        selected: [],\n        touched: [],\n        changed: {\n            added: [], // Added elements since last selection\n            removed: [] // Removed elements since last selection\n        }\n    };\n\n    // Area element and clipping element\n    private readonly _area: HTMLElement;\n    private readonly _clippingElement: HTMLElement;\n\n    // Target container (element) and boundary (cached)\n    private _targetElement?: Element;\n    private _targetRect?: DOMRect;\n    private _selectables: Element[] = [];\n    private _latestElement?: Element;\n\n    // Caches the position of the selection-area\n    private readonly _areaRect = new DOMRect();\n\n    // Dynamically constructed area rect\n    private _areaLocation: AreaLocation = {y1: 0, x2: 0, y2: 0, x1: 0};\n\n    // If a single click is being performed.\n    // It's a single-click until the user dragged the mouse.\n    private _singleClick = true;\n    private _frame: Frames;\n\n    // Is getting set on movement.\n    private _scrollAvailable = true;\n    private _scrollingActive = false;\n    private _scrollSpeed: Coordinates = {x: 0, y: 0};\n    private _scrollDelta: Coordinates = {x: 0, y: 0};\n\n    constructor(opt: PartialSelectionOptions) {\n        super();\n\n        this._options = deepAssign<SelectionOptions>({\n            selectionAreaClass: 'selection-area',\n            selectionContainerClass: undefined,\n            selectables: [],\n            document: window.document,\n\n            behaviour: {\n                overlap: 'invert',\n                intersect: 'touch',\n                startThreshold: {x: 10, y: 10},\n                scrolling: {\n                    speedDivider: 10,\n                    manualSpeed: 750,\n                    startScrollMargins: {x: 0, y: 0}\n                }\n            },\n\n            features: {\n                range: true,\n                touch: true,\n                singleTap: {\n                    allow: true,\n                    intersect: 'native'\n                }\n            },\n\n            startAreas: ['html'],\n            boundaries: ['html'],\n            container: 'body'\n        }, opt);\n\n        // Bind locale functions to instance\n        /* eslint-disable @typescript-eslint/no-explicit-any */\n        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n            if (typeof (this as any)[key] === 'function') {\n                (this as any)[key] = (this as any)[key].bind(this);\n            }\n        }\n\n        const {document, selectionAreaClass, selectionContainerClass} = this._options;\n        this._area = document.createElement('div');\n        this._clippingElement = document.createElement('div');\n        this._clippingElement.appendChild(this._area);\n\n        this._area.classList.add(selectionAreaClass);\n        selectionContainerClass && this._clippingElement.classList.add(selectionContainerClass);\n\n        css(this._area, {\n            willChange: 'top, left, bottom, right, width, height',\n            top: 0,\n            left: 0,\n            position: 'fixed'\n        });\n\n        css(this._clippingElement, {\n            overflow: 'hidden',\n            position: 'fixed',\n            transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\n            pointerEvents: 'none',\n            zIndex: '1'\n        });\n\n        this._frame = frames((evt: MouseEvent | TouchEvent) => {\n            this._recalculateSelectionAreaRect();\n            this._updateElementSelection();\n            this._emitEvent('move', evt);\n            this._redrawSelectionArea();\n        });\n\n        this.enable();\n    }\n\n    _bindStartEvents(activate = true): void {\n        const {document, features} = this._options;\n        const fn = activate ? on : off;\n\n        fn(document, 'mousedown', this._onTapStart);\n        features.touch && fn(document, 'touchstart', this._onTapStart, {\n            passive: false\n        });\n    }\n\n    _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\n        const {x, y, target} = simplifyEvent(evt);\n        const {_options} = this;\n        const {document} = this._options;\n        const targetBoundingClientRect = target.getBoundingClientRect();\n\n        // Find start-areas and boundaries\n        const startAreas = selectAll(_options.startAreas, _options.document);\n        const resolvedBoundaries = selectAll(_options.boundaries, _options.document);\n\n        // Check in which container the user currently acts\n        this._targetElement = resolvedBoundaries.find(el =>\n            intersects(el.getBoundingClientRect(), targetBoundingClientRect)\n        );\n\n        // Check if area starts in one of the start areas / boundaries\n        const evtPath = evt.composedPath();\n        if (!this._targetElement ||\n            !startAreas.find(el => evtPath.includes(el)) ||\n            !resolvedBoundaries.find(el => evtPath.includes(el))) {\n            return;\n        }\n\n        if (!silent && this._emitEvent('beforestart', evt) === false) {\n            return;\n        }\n\n        this._areaLocation = {x1: x, y1: y, x2: 0, y2: 0};\n\n        // Lock scrolling in target container\n        const scrollElement = document.scrollingElement || document.body;\n        this._scrollDelta = {x: scrollElement.scrollLeft, y: scrollElement.scrollTop};\n\n        // To detect single-click\n        this._singleClick = true;\n        this.clearSelection(false, true);\n\n        on(document, ['touchmove', 'mousemove'], this._delayedTapMove, {passive: false});\n        on(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        on(document, 'scroll', this._onScroll);\n    }\n\n    _onSingleTap(evt: MouseEvent | TouchEvent): void {\n        const {singleTap: {intersect}, range} = this._options.features;\n        const e = simplifyEvent(evt);\n        let target;\n\n        if (intersect === 'native') {\n            target = e.target;\n        } else if (intersect === 'touch') {\n            this.resolveSelectables();\n\n            const {x, y} = e;\n            target = this._selectables.find(v => {\n                const {right, left, top, bottom} = v.getBoundingClientRect();\n                return x < right && x > left && y < bottom && y > top;\n            });\n        }\n\n        if (!target) {\n            return;\n        }\n\n        /**\n         * Resolve selectables again.\n         * If the user started in a scrollable area they will be reduced\n         * to the current area. Prevent the exclusion of these if a range-selection\n         * gets performed.\n         */\n        this.resolveSelectables();\n\n        // Traverse dom upwards to check if target is selectable\n        while (!this._selectables.includes(target)) {\n            if (!target.parentElement) {\n                return;\n            }\n\n            target = target.parentElement;\n        }\n\n        // Grab current store first in case it gets set back\n        const {stored} = this._selection;\n        this._emitEvent('start', evt);\n\n        if (evt.shiftKey && stored.length && range) {\n            const reference = this._latestElement ?? stored[0];\n\n            // Resolve correct range\n            const [preceding, following] = reference.compareDocumentPosition(target) & 4 ?\n                [target, reference] : [reference, target];\n\n            const rangeItems = [...this._selectables.filter(el =>\n                (el.compareDocumentPosition(preceding) & 4) &&\n                (el.compareDocumentPosition(following) & 2)\n            ), preceding, following];\n\n            this.select(rangeItems);\n        } else if (\n            stored.includes(target) && (\n                stored.length === 1 || evt.ctrlKey ||\n                stored.every(v => this._selection.stored.includes(v))\n            )\n        ) {\n            this.deselect(target);\n        } else {\n            this._latestElement = target;\n            this.select(target);\n        }\n\n        this._emitEvent('stop', evt);\n    }\n\n    _delayedTapMove(evt: MouseEvent | TouchEvent): void {\n        const {container, document, behaviour: {startThreshold}} = this._options;\n        const {x1, y1} = this._areaLocation; // Coordinates of first \"tap\"\n        const {x, y} = simplifyEvent(evt);\n\n        // Check pixel threshold\n        const thresholdType = typeof startThreshold;\n        if (\n\n            // Single number for both coordinates\n            (thresholdType === 'number' && abs((x + y) - (x1 + y1)) >= startThreshold) ||\n\n            // Different x and y threshold\n            (thresholdType === 'object' && abs(x - x1) >= (startThreshold as Coordinates).x || abs(y - y1) >= (startThreshold as Coordinates).y)\n        ) {\n            off(document, ['mousemove', 'touchmove'], this._delayedTapMove, {passive: false});\n\n            if (this._emitEvent('beforedrag', evt) === false) {\n                off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n                return;\n            }\n\n            on(document, ['mousemove', 'touchmove'], this._onTapMove, {passive: false});\n\n            // Make area element visible\n            css(this._area, 'display', 'block');\n\n            // Append selection-area to the dom\n            selectAll(container, document)[0].appendChild(this._clippingElement);\n\n            this.resolveSelectables();\n\n            // An action is recognized as single-select until the user performed a multi-selection\n            this._singleClick = false;\n\n            // Just saving the boundaries of this container for later\n            this._targetRect = this._targetElement!.getBoundingClientRect();\n\n            // Find container and check if it's scrollable\n            this._scrollAvailable =\n                this._targetElement!.scrollHeight !== this._targetElement!.clientHeight ||\n                this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\n\n            if (this._scrollAvailable) {\n\n                // Detect mouse scrolling\n                on(document, 'wheel', this._manualScroll, {passive: false});\n\n                /**\n                 * The selection-area will also cover other element which are\n                 * out of the current scrollable parent. So find all elements\n                 * which are in the current scrollable element. Later these are\n                 * the only selectables instead of all.\n                 */\n                this._selectables = this._selectables.filter(s => this._targetElement!.contains(s));\n            }\n\n            // Re-setup selection area and fire event\n            this._setupSelectionArea();\n            this._emitEvent('start', evt);\n            this._onTapMove(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _setupSelectionArea(): void {\n        const {_clippingElement, _targetElement, _area} = this;\n        const tr = this._targetRect = _targetElement!.getBoundingClientRect();\n\n        if (this._scrollAvailable) {\n\n            /**\n             * To clip the area, the selection area has a parent\n             * which has exact the same dimensions as the scrollable element.\n             * Now if the area exceeds these boundaries it will be cropped.\n             */\n            css(_clippingElement, {\n                top: tr.top,\n                left: tr.left,\n                width: tr.width,\n                height: tr.height\n            });\n\n            /**\n             * The area element is relative to the clipping element,\n             * but when this is moved or transformed we need to correct\n             * the positions via a negative margin.\n             */\n            css(_area, {\n                marginTop: -tr.top,\n                marginLeft: -tr.left\n            });\n        } else {\n\n            // \"Reset\" styles\n            css(_clippingElement, {\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%'\n            });\n\n            css(_area, {\n                marginTop: 0,\n                marginLeft: 0\n            });\n        }\n    }\n\n    _onTapMove(evt: MouseEvent | TouchEvent): void {\n        const {x, y} = simplifyEvent(evt);\n        const {_scrollSpeed, _areaLocation, _options, _frame} = this;\n        const {speedDivider} = _options.behaviour.scrolling;\n        const _targetElement = this._targetElement as Element;\n\n        _areaLocation.x2 = x;\n        _areaLocation.y2 = y;\n\n        if (this._scrollAvailable && !this._scrollingActive && (_scrollSpeed.y || _scrollSpeed.x)) {\n\n            // Continuous scrolling\n            this._scrollingActive = true;\n\n            const scroll = () => {\n                if (!_scrollSpeed.x && !_scrollSpeed.y) {\n                    this._scrollingActive = false;\n                    return;\n                }\n\n                // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\n                const {scrollTop, scrollLeft} = _targetElement;\n\n                if (_scrollSpeed.y) {\n                    _targetElement.scrollTop += ceil(_scrollSpeed.y / speedDivider);\n                    _areaLocation.y1 -= _targetElement.scrollTop - scrollTop;\n                }\n\n                if (_scrollSpeed.x) {\n                    _targetElement.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\n                    _areaLocation.x1 -= _targetElement.scrollLeft - scrollLeft;\n                }\n\n                /**\n                 * We changed the start coordinates -> redraw the selection-area\n                 * We changed the dimensions of the area element -> re-calc selected elements\n                 * The selected elements array has been changed -> fire event\n                 */\n                _frame.next(evt);\n\n                // Keep scrolling even if the user stops to move his pointer\n                requestAnimationFrame(scroll);\n            };\n\n            requestAnimationFrame(scroll);\n        } else {\n\n            /**\n             * Perform redraw only if scrolling is not active.\n             * If scrolling is active this area is getting re-dragged by the\n             * anonymize scroll function.\n             */\n            _frame.next(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _handleMoveEvent(evt: MouseEvent | TouchEvent) {\n        const {features} = this._options;\n\n        /**\n         * - Prevent auto-refresh for when pulling down on touch devices.\n         * - Prevent auto-scroll by the browser when on safari and scrolling is handled by viselect.\n         */\n        if ((features.touch && isTouchDevice()) || (this._scrollAvailable && isSafariBrowser())) {\n            evt.preventDefault(); // Prevent swipe-down refresh\n        }\n    }\n\n    _onScroll(): void {\n        const {_scrollDelta, _options: {document}} = this;\n        const {scrollTop, scrollLeft} = document.scrollingElement || document.body;\n\n        // Adjust area start location\n        this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\n        this._areaLocation.y1 += _scrollDelta.y - scrollTop;\n        _scrollDelta.x = scrollLeft;\n        _scrollDelta.y = scrollTop;\n\n        // The area needs to be set back as the target-container has changed in its position\n        this._setupSelectionArea();\n        this._frame.next(null);\n    }\n\n    _manualScroll(evt: ScrollEvent): void {\n        const {manualSpeed} = this._options.behaviour.scrolling;\n\n        // Consistent scrolling speed on all browsers\n        const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\n        const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\n        this._scrollSpeed.y += deltaY * manualSpeed;\n        this._scrollSpeed.x += deltaX * manualSpeed;\n        this._onTapMove(evt);\n\n        // Prevent default scrolling behaviour, e.g. page scrolling\n        evt.preventDefault();\n    }\n\n    _recalculateSelectionAreaRect(): void {\n        const {_scrollSpeed, _areaLocation, _areaRect, _targetElement, _options} = this;\n        const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = _targetElement as Element;\n        const _targetRect = this._targetRect as DOMRect;\n\n        const {x1, y1} = _areaLocation;\n        let {x2, y2} = _areaLocation;\n\n        const {behaviour: {scrolling: {startScrollMargins}}} = _options;\n\n        if (x2 < _targetRect.left + startScrollMargins.x) {\n            _scrollSpeed.x = scrollLeft ? -abs(_targetRect.left - x2 + startScrollMargins.x) : 0;\n            x2 = x2 < _targetRect.left ? _targetRect.left : x2;\n        } else if (x2 > _targetRect.right - startScrollMargins.x) {\n            _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(_targetRect.left + _targetRect.width - x2 - startScrollMargins.x) : 0;\n            x2 = x2 > _targetRect.right ? _targetRect.right : x2;\n        } else {\n            _scrollSpeed.x = 0;\n        }\n\n        if (y2 < _targetRect.top + startScrollMargins.y) {\n            _scrollSpeed.y = scrollTop ? -abs(_targetRect.top - y2 + startScrollMargins.y) : 0;\n            y2 = y2 < _targetRect.top ? _targetRect.top : y2;\n        } else if (y2 > _targetRect.bottom - startScrollMargins.y) {\n            _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(_targetRect.top + _targetRect.height - y2 - startScrollMargins.y) : 0;\n            y2 = y2 > _targetRect.bottom ? _targetRect.bottom : y2;\n        } else {\n            _scrollSpeed.y = 0;\n        }\n\n        const x3 = min(x1, x2);\n        const y3 = min(y1, y2);\n        const x4 = max(x1, x2);\n        const y4 = max(y1, y2);\n\n        _areaRect.x = x3;\n        _areaRect.y = y3;\n        _areaRect.width = x4 - x3;\n        _areaRect.height = y4 - y3;\n    }\n\n    _redrawSelectionArea(): void {\n        const {x, y, width, height} = this._areaRect;\n        const {style} = this._area;\n\n        // Using transform will make the area's borders look blurry\n        style.left = `${x}px`;\n        style.top = `${y}px`;\n        style.width = `${width}px`;\n        style.height = `${height}px`;\n    }\n\n    _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\n        const {document, features} = this._options;\n        const {_singleClick} = this;\n\n        // Remove event handlers\n        off(document, ['mousemove', 'touchmove'], this._delayedTapMove);\n        off(document, ['touchmove', 'mousemove'], this._onTapMove);\n        off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        off(document, 'scroll', this._onScroll);\n\n        // Keep selection until the next time\n        this._keepSelection();\n\n        if (evt && _singleClick && features.singleTap.allow) {\n            this._onSingleTap(evt);\n        } else if (!_singleClick && !silent) {\n            this._updateElementSelection();\n            this._emitEvent('stop', evt);\n        }\n\n        this._scrollSpeed.x = 0;\n        this._scrollSpeed.y = 0;\n\n        // Unbind mouse scrolling listener\n        this._scrollAvailable && off(document, 'wheel', this._manualScroll, {passive: true});\n\n        // Remove selection-area from dom\n        this._clippingElement.remove();\n\n        // Cancel current frame\n        this._frame?.cancel();\n\n        // Hide selection area\n        css(this._area, 'display', 'none');\n    }\n\n    _updateElementSelection(): void {\n        const {_selectables, _options, _selection, _areaRect} = this;\n        const {stored, selected, touched} = _selection;\n        const {intersect, overlap} = _options.behaviour;\n\n        const invert = overlap === 'invert';\n        const newlyTouched: Element[] = [];\n        const added: Element[] = [];\n        const removed: Element[] = [];\n\n        // Find newly selected elements\n        for (let i = 0; i < _selectables.length; i++) {\n            const node = _selectables[i];\n\n            // Check if area intersects element\n            if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\n\n                // Check if the element wasn't present in the last selection.\n                if (!selected.includes(node)) {\n\n                    // Check if user wants to invert the selection for already selected elements\n                    if (invert && stored.includes(node)) {\n                        removed.push(node);\n                        continue;\n                    } else {\n                        added.push(node);\n                    }\n                } else if (stored.includes(node) && !touched.includes(node)) {\n                    touched.push(node);\n                }\n\n                newlyTouched.push(node);\n            }\n        }\n\n        // Re-select elements which were previously stored\n        if (invert) {\n            added.push(...stored.filter(v => !selected.includes(v)));\n        }\n\n        // Check which elements where removed since last selection\n        const keep = overlap === 'keep';\n        for (let i = 0; i < selected.length; i++) {\n            const node = selected[i];\n\n            if (!newlyTouched.includes(node) && !(\n\n                // Check if user wants to keep previously selected elements, e.g.\n                // not make them part of the current selection as soon as they're touched.\n                keep && stored.includes(node)\n            )) {\n                removed.push(node);\n            }\n        }\n\n        _selection.selected = newlyTouched;\n        _selection.changed = {added, removed};\n        this._latestElement = newlyTouched[newlyTouched.length - 1];\n    }\n\n    _emitEvent(name: keyof SelectionEvents, evt: MouseEvent | TouchEvent | null): unknown {\n        return this.emit(name, {\n            event: evt,\n            store: this._selection,\n            selection: this\n        });\n    }\n\n    _keepSelection(): void {\n        const {_options, _selection} = this;\n        const {selected, changed, touched, stored} = _selection;\n        const addedElements = selected.filter(el => !stored.includes(el));\n\n        switch (_options.behaviour.overlap) {\n            case 'drop': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !touched.includes(el))  // Elements not touched\n                ];\n                break;\n            }\n            case 'invert': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !changed.removed.includes(el))  // Elements not removed from selection\n                ];\n                break;\n            }\n            case 'keep': {\n                _selection.stored = [\n                    ...stored,\n                    ...selected.filter(el => !stored.includes(el)) // Newly added\n                ];\n                break;\n            }\n        }\n    }\n\n    /**\n     * Manually triggers the start of a selection\n     * @param evt A MouseEvent / TouchEvent -like object\n     * @param silent If beforestart should be fired,\n     */\n    trigger(evt: MouseEvent | TouchEvent, silent = true): void {\n        this._onTapStart(evt, silent);\n    }\n\n    /**\n     * Can be used if during a selection elements have been added.\n     * Will update everything which can be selected.\n     */\n    resolveSelectables(): void {\n        this._selectables = selectAll(this._options.selectables, this._options.document);\n    }\n\n    /**\n     * Same as deselect, but for all elements currently selected.\n     * @param includeStored If the store should also get cleared\n     * @param quiet If move / stop events should be fired\n     */\n    clearSelection(includeStored = true, quiet = false): void {\n        const {selected, stored, changed} = this._selection;\n\n        changed.added = [];\n        changed.removed.push(\n            ...selected,\n            ...(includeStored ? stored : [])\n        );\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        // Reset state\n        this._latestElement = undefined;\n        this._selection = {\n            stored: includeStored ? [] : stored,\n            selected: [],\n            touched: [],\n            changed: {added: [], removed: []}\n        };\n    }\n\n    /**\n     * @returns {Array} Selected elements\n     */\n    getSelection(): Element[] {\n        return this._selection.stored;\n    }\n\n    /**\n     * @returns {HTMLElement} The selection area element\n     */\n    getSelectionArea(): HTMLElement {\n        return this._area;\n    }\n\n    /**\n     * Cancel the current selection process.\n     * @param keepEvent {boolean} true to fire a stop event after cancel.\n     */\n    cancel(keepEvent = false): void {\n        this._onTapStop(null, !keepEvent);\n    }\n\n    /**\n     * Unbinds all events and removes the area-element.\n     */\n    destroy(): void {\n        this.cancel();\n        this.disable();\n        this._clippingElement.remove();\n        super.unbindAllListeners();\n    }\n\n    /* eslint-disable no-invalid-this */\n    disable = this._bindStartEvents.bind(this, false);\n    enable = this._bindStartEvents;\n\n    /**\n     * Adds elements to the selection\n     * @param query - CSS Query, can be an array of queries\n     * @param quiet - If this should not trigger the move event\n     */\n    select(query: SelectAllSelectors, quiet = false): Element[] {\n        const {changed, selected, stored} = this._selection;\n        const elements = selectAll(query, this._options.document).filter(el =>\n            !selected.includes(el) &&\n            !stored.includes(el)\n        );\n\n        // Update element lists\n        stored.push(...elements);\n        selected.push(...elements);\n        changed.added.push(...elements);\n        changed.removed = [];\n\n        // We don't know which element was \"selected\" first so clear it\n        this._latestElement = undefined;\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        return elements;\n    }\n\n    /**\n     * Removes a particular element from the selection.\n     * @param query - CSS Query, can be an array of queries\n     * @param quiet - If this should not trigger the move event\n     */\n    deselect(query: SelectAllSelectors, quiet = false) {\n        const {selected, stored, changed} = this._selection;\n\n        const elements = selectAll(query, this._options.document).filter(el =>\n            selected.includes(el) ||\n            stored.includes(el)\n        );\n\n        if (!elements.length) {\n            return;\n        }\n\n        this._selection.stored = stored.filter(el => !elements.includes(el));\n        this._selection.selected = selected.filter(el => !elements.includes(el));\n        this._selection.changed.added = [];\n        this._selection.changed.removed.push(\n            ...elements.filter(el => !changed.removed.includes(el))\n        );\n\n        // We don't know which element was \"selected\" first so clear it\n        this._latestElement = undefined;\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n    }\n}\n"],"names":["EventTarget","__publicField","event","cb","set","_a","data","ok","unitify","val","unit","css","style","attr","key","value","eventListener","method","items","events","fn","options","el","ev","on","off","simplifyEvent","evt","clientX","clientY","target","intersects","a","b","mode","bxc","byc","selectAll","selector","doc","list","nodes","i","l","item","isTouchDevice","isSafariBrowser","deepAssign","source","sourceValue","frames","previousArgs","frameId","lock","args","abs","max","min","ceil","SelectionArea","opt","document","selectionAreaClass","selectionContainerClass","activate","features","silent","x","y","_options","targetBoundingClientRect","startAreas","resolvedBoundaries","evtPath","scrollElement","intersect","range","e","v","right","left","top","bottom","stored","reference","preceding","following","rangeItems","container","startThreshold","x1","y1","thresholdType","s","_clippingElement","_targetElement","_area","tr","_scrollSpeed","_areaLocation","_frame","speedDivider","scroll","scrollTop","scrollLeft","_scrollDelta","manualSpeed","deltaY","deltaX","_areaRect","scrollHeight","clientHeight","scrollWidth","clientWidth","_targetRect","x2","y2","startScrollMargins","x3","y3","x4","y4","width","height","_singleClick","_selectables","_selection","selected","touched","overlap","invert","newlyTouched","added","removed","node","keep","name","changed","addedElements","includeStored","quiet","keepEvent","query","elements"],"mappings":"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"}