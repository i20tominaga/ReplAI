{"version":3,"file":"viselect.umd.js","sources":["../src/EventEmitter.ts","../src/utils/css.ts","../src/utils/events.ts","../src/utils/intersects.ts","../src/utils/selectAll.ts","../src/utils/constants.ts","../src/utils/deepAssign.ts","../src/utils/frames.ts","../src/index.ts"],"sourcesContent":["\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => any;\ntype EventMap = Record<string, AnyFunction>;\n\nexport class EventTarget<Events extends EventMap> {\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\n\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        const set = this._listeners.get(event) || new Set();\n        this._listeners.set(event, set);\n        set.add(cb as AnyFunction);\n        return this;\n    }\n\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        this._listeners.get(event)?.delete(cb as AnyFunction);\n        return this;\n    }\n\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): unknown {\n        let ok = true;\n        for (const cb of (this._listeners.get(event) || [])) {\n            ok = (cb(...data) !== false) && ok;\n        }\n\n        return ok;\n    }\n\n    public unbindAllListeners(): void {\n        this._listeners.clear();\n    }\n\n    // Let's also support on, off and emit like node\n    /* eslint-disable no-invalid-this */\n    public on = this.addEventListener;\n    public off = this.removeEventListener;\n    public emit = this.dispatchEvent;\n}\n","const unitify = (val: string | number, unit = 'px'): string => {\n    return typeof val === 'number' ? val + unit : val;\n};\n\n/**\n * Add css to a DOM-Element or returns the current\n * value of a property.\n *\n * @param el The Element.\n * @param attr The attribute or an object which holds css key-properties.\n * @param val The value for a single attribute.\n * @returns {*}\n */\nexport function css(\n    {style}: HTMLElement,\n    attr: Partial<Record<keyof CSSStyleDeclaration, string | number>> | string,\n    val?: string | number\n): void {\n    if (typeof attr === 'object') {\n\n        for (const [key, value] of Object.entries(attr)) {\n            value !== undefined && (style[key as any] = unitify(value));\n        }\n\n    } else if (val !== undefined) {\n        style[attr as any] = unitify(val);\n    }\n}\n\n\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype Method = 'addEventListener' | 'removeEventListener';\ntype AnyFunction = (...arg: any) => any;\n\nexport type EventBindingArgs = [\n        EventTarget | EventTarget[],\n        string | string[],\n    AnyFunction,\n    Record<string, unknown>?\n];\n\ninterface EventBinding {\n    (\n        elements: EventTarget | EventTarget[],\n        events: string | string[],\n        fn: AnyFunction,\n        options?: Record<string, unknown>\n    ): EventBindingArgs;\n}\n\n/* eslint-disable prefer-rest-params */\nfunction eventListener(method: Method): EventBinding {\n    return (\n        items: EventTarget | EventTarget[],\n        events: string | string[],\n        fn: AnyFunction, options = {}\n    ): EventBindingArgs => {\n\n        // Normalize array\n        if (items instanceof HTMLCollection || items instanceof NodeList) {\n            items = Array.from(items);\n        } else if (!Array.isArray(items)) {\n            items = [items];\n        }\n\n        if (!Array.isArray(events)) {\n            events = [events];\n        }\n\n        for (const el of items) {\n            for (const ev of events) {\n                el[method](ev, fn as EventListener, {capture: false, ...options});\n            }\n        }\n\n        return [items, events, fn, options];\n    };\n}\n\n/**\n * Add event(s) to element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const on = eventListener('addEventListener');\n\n/**\n * Remove event(s) from element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const off = eventListener('removeEventListener');\n\n/**\n * Simplifies a touch / mouse-event\n * @param evt\n */\nexport const simplifyEvent = (evt: any): {\n    target: HTMLElement;\n    x: number;\n    y: number;\n} => {\n    const { clientX, clientY, target } = (evt.touches && evt.touches[0] || evt);\n    return {x: clientX, y: clientY, target};\n};\n","export type Intersection = 'center' | 'cover' | 'touch'\n\n/**\n * Check if two DOM-Elements intersects each other.\n * @param a BoundingClientRect of the first element.\n * @param b BoundingClientRect of the second element.\n * @param mode Options are center, cover or touch.\n * @returns {boolean} If both elements intersects each other.\n */\nexport function intersects(a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean {\n    switch (mode) {\n        case 'center': {\n            const bxc = b.left + b.width / 2;\n            const byc = b.top + b.height / 2;\n\n            return bxc >= a.left &&\n                bxc <= a.right &&\n                byc >= a.top &&\n                byc <= a.bottom;\n        }\n        case 'cover': {\n            return b.left >= a.left &&\n                b.top >= a.top &&\n                b.right <= a.right &&\n                b.bottom <= a.bottom;\n        }\n        case 'touch': {\n            return a.right >= b.left &&\n                a.left <= b.right &&\n                a.bottom >= b.top &&\n                a.top <= b.bottom;\n        }\n    }\n}\n","export type SelectAllSelectors = readonly (string | Element)[] | string | Element;\n\n/**\n * Takes a selector (or array of selectors) and returns the matched nodes.\n * @param selector The selector or an Array of selectors.\n * @param doc\n * @returns {Array} Array of DOM-Nodes.\n */\nexport function selectAll(selector: SelectAllSelectors, doc: Document = document): Element[] {\n    const list = !Array.isArray(selector) ? [selector] : selector;\n    let nodes: Element[] = [];\n\n    for (let i = 0, l = list.length; i < l; i++) {\n        const item = list[i];\n\n        if (typeof item === 'string') {\n            /**\n             * We can't use the spread operator here as with large amounts of elements\n             * we'll get a \"Maximum call stack size exceeded\"-error.\n             */\n            nodes = nodes.concat(Array.from(doc.querySelectorAll(item)));\n        } else if (item instanceof Element) {\n            nodes.push(item);\n        }\n    }\n\n    return nodes;\n}\n","// Determines if the device's primary input supports touch\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\nexport const isTouchDevice = (): boolean => matchMedia('(hover: none), (pointer: coarse)').matches;\n\n// Determines if the browser is safari\nexport const isSafariBrowser = (): boolean => 'safari' in window;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nexport const deepAssign = <O extends Record<any, any>>(target: O, source: any): O => {\n    for (const [key, value] of Object.entries(target)) {\n        const sourceValue = source[key];\n\n        // Use the default value if there's no value specified\n        target[key as keyof O] = sourceValue === undefined ? target[key as keyof O] :\n\n            // Check if it's a nested object and merge if required\n            (typeof sourceValue === 'object' && typeof value === 'object' && value !== null && !Array.isArray(value)) ?\n                deepAssign(value as O, sourceValue as Partial<O>) : sourceValue;\n    }\n\n    return target;\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => void;\n\nexport interface Frames<F extends AnyFunction = AnyFunction> {\n    next(...args: Parameters<F>): void;\n\n    cancel(): void;\n}\n\nexport const frames = <F extends AnyFunction>(fn: F): Frames<F> => {\n    let previousArgs: Parameters<F>;\n    let frameId = -1;\n    let lock = false;\n\n    return {\n        next(...args: Parameters<F>): void {\n            previousArgs = args;\n\n            if (!lock) {\n                lock = true;\n                frameId = requestAnimationFrame(() => {\n                    fn(...previousArgs);\n                    lock = false;\n                });\n            }\n        },\n        cancel() {\n            cancelAnimationFrame(frameId);\n            lock = false;\n        }\n    };\n};\n","import {EventTarget} from './EventEmitter';\nimport type {AreaLocation, Coordinates, ScrollEvent, SelectionEvents, SelectionOptions, SelectionStore} from './types';\nimport {PartialSelectionOptions} from './types';\nimport {css, deepAssign, frames, Frames, intersects, isSafariBrowser, isTouchDevice, off, on, selectAll, SelectAllSelectors, simplifyEvent} from './utils';\n\n// Re-export types\nexport * from './types';\n\n// Some var shorting for better compression and readability\nconst {abs, max, min, ceil} = Math;\n\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\n    public static version = VERSION;\n\n    // Options\n    private readonly _options: SelectionOptions;\n\n    // Selection store\n    private _selection: SelectionStore = {\n        stored: [],\n        selected: [],\n        touched: [],\n        changed: {\n            added: [], // Added elements since last selection\n            removed: [] // Removed elements since last selection\n        }\n    };\n\n    // Area element and clipping element\n    private readonly _area: HTMLElement;\n    private readonly _clippingElement: HTMLElement;\n\n    // Target container (element) and boundary (cached)\n    private _targetElement?: Element;\n    private _targetRect?: DOMRect;\n    private _selectables: Element[] = [];\n    private _latestElement?: Element;\n\n    // Caches the position of the selection-area\n    private readonly _areaRect = new DOMRect();\n\n    // Dynamically constructed area rect\n    private _areaLocation: AreaLocation = {y1: 0, x2: 0, y2: 0, x1: 0};\n\n    // If a single click is being performed.\n    // It's a single-click until the user dragged the mouse.\n    private _singleClick = true;\n    private _frame: Frames;\n\n    // Is getting set on movement.\n    private _scrollAvailable = true;\n    private _scrollingActive = false;\n    private _scrollSpeed: Coordinates = {x: 0, y: 0};\n    private _scrollDelta: Coordinates = {x: 0, y: 0};\n\n    constructor(opt: PartialSelectionOptions) {\n        super();\n\n        this._options = deepAssign<SelectionOptions>({\n            selectionAreaClass: 'selection-area',\n            selectionContainerClass: undefined,\n            selectables: [],\n            document: window.document,\n\n            behaviour: {\n                overlap: 'invert',\n                intersect: 'touch',\n                startThreshold: {x: 10, y: 10},\n                scrolling: {\n                    speedDivider: 10,\n                    manualSpeed: 750,\n                    startScrollMargins: {x: 0, y: 0}\n                }\n            },\n\n            features: {\n                range: true,\n                touch: true,\n                singleTap: {\n                    allow: true,\n                    intersect: 'native'\n                }\n            },\n\n            startAreas: ['html'],\n            boundaries: ['html'],\n            container: 'body'\n        }, opt);\n\n        // Bind locale functions to instance\n        /* eslint-disable @typescript-eslint/no-explicit-any */\n        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n            if (typeof (this as any)[key] === 'function') {\n                (this as any)[key] = (this as any)[key].bind(this);\n            }\n        }\n\n        const {document, selectionAreaClass, selectionContainerClass} = this._options;\n        this._area = document.createElement('div');\n        this._clippingElement = document.createElement('div');\n        this._clippingElement.appendChild(this._area);\n\n        this._area.classList.add(selectionAreaClass);\n        selectionContainerClass && this._clippingElement.classList.add(selectionContainerClass);\n\n        css(this._area, {\n            willChange: 'top, left, bottom, right, width, height',\n            top: 0,\n            left: 0,\n            position: 'fixed'\n        });\n\n        css(this._clippingElement, {\n            overflow: 'hidden',\n            position: 'fixed',\n            transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\n            pointerEvents: 'none',\n            zIndex: '1'\n        });\n\n        this._frame = frames((evt: MouseEvent | TouchEvent) => {\n            this._recalculateSelectionAreaRect();\n            this._updateElementSelection();\n            this._emitEvent('move', evt);\n            this._redrawSelectionArea();\n        });\n\n        this.enable();\n    }\n\n    _bindStartEvents(activate = true): void {\n        const {document, features} = this._options;\n        const fn = activate ? on : off;\n\n        fn(document, 'mousedown', this._onTapStart);\n        features.touch && fn(document, 'touchstart', this._onTapStart, {\n            passive: false\n        });\n    }\n\n    _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\n        const {x, y, target} = simplifyEvent(evt);\n        const {_options} = this;\n        const {document} = this._options;\n        const targetBoundingClientRect = target.getBoundingClientRect();\n\n        // Find start-areas and boundaries\n        const startAreas = selectAll(_options.startAreas, _options.document);\n        const resolvedBoundaries = selectAll(_options.boundaries, _options.document);\n\n        // Check in which container the user currently acts\n        this._targetElement = resolvedBoundaries.find(el =>\n            intersects(el.getBoundingClientRect(), targetBoundingClientRect)\n        );\n\n        // Check if area starts in one of the start areas / boundaries\n        const evtPath = evt.composedPath();\n        if (!this._targetElement ||\n            !startAreas.find(el => evtPath.includes(el)) ||\n            !resolvedBoundaries.find(el => evtPath.includes(el))) {\n            return;\n        }\n\n        if (!silent && this._emitEvent('beforestart', evt) === false) {\n            return;\n        }\n\n        this._areaLocation = {x1: x, y1: y, x2: 0, y2: 0};\n\n        // Lock scrolling in target container\n        const scrollElement = document.scrollingElement || document.body;\n        this._scrollDelta = {x: scrollElement.scrollLeft, y: scrollElement.scrollTop};\n\n        // To detect single-click\n        this._singleClick = true;\n        this.clearSelection(false, true);\n\n        on(document, ['touchmove', 'mousemove'], this._delayedTapMove, {passive: false});\n        on(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        on(document, 'scroll', this._onScroll);\n    }\n\n    _onSingleTap(evt: MouseEvent | TouchEvent): void {\n        const {singleTap: {intersect}, range} = this._options.features;\n        const e = simplifyEvent(evt);\n        let target;\n\n        if (intersect === 'native') {\n            target = e.target;\n        } else if (intersect === 'touch') {\n            this.resolveSelectables();\n\n            const {x, y} = e;\n            target = this._selectables.find(v => {\n                const {right, left, top, bottom} = v.getBoundingClientRect();\n                return x < right && x > left && y < bottom && y > top;\n            });\n        }\n\n        if (!target) {\n            return;\n        }\n\n        /**\n         * Resolve selectables again.\n         * If the user started in a scrollable area they will be reduced\n         * to the current area. Prevent the exclusion of these if a range-selection\n         * gets performed.\n         */\n        this.resolveSelectables();\n\n        // Traverse dom upwards to check if target is selectable\n        while (!this._selectables.includes(target)) {\n            if (!target.parentElement) {\n                return;\n            }\n\n            target = target.parentElement;\n        }\n\n        // Grab current store first in case it gets set back\n        const {stored} = this._selection;\n        this._emitEvent('start', evt);\n\n        if (evt.shiftKey && stored.length && range) {\n            const reference = this._latestElement ?? stored[0];\n\n            // Resolve correct range\n            const [preceding, following] = reference.compareDocumentPosition(target) & 4 ?\n                [target, reference] : [reference, target];\n\n            const rangeItems = [...this._selectables.filter(el =>\n                (el.compareDocumentPosition(preceding) & 4) &&\n                (el.compareDocumentPosition(following) & 2)\n            ), preceding, following];\n\n            this.select(rangeItems);\n        } else if (\n            stored.includes(target) && (\n                stored.length === 1 || evt.ctrlKey ||\n                stored.every(v => this._selection.stored.includes(v))\n            )\n        ) {\n            this.deselect(target);\n        } else {\n            this._latestElement = target;\n            this.select(target);\n        }\n\n        this._emitEvent('stop', evt);\n    }\n\n    _delayedTapMove(evt: MouseEvent | TouchEvent): void {\n        const {container, document, behaviour: {startThreshold}} = this._options;\n        const {x1, y1} = this._areaLocation; // Coordinates of first \"tap\"\n        const {x, y} = simplifyEvent(evt);\n\n        // Check pixel threshold\n        const thresholdType = typeof startThreshold;\n        if (\n\n            // Single number for both coordinates\n            (thresholdType === 'number' && abs((x + y) - (x1 + y1)) >= startThreshold) ||\n\n            // Different x and y threshold\n            (thresholdType === 'object' && abs(x - x1) >= (startThreshold as Coordinates).x || abs(y - y1) >= (startThreshold as Coordinates).y)\n        ) {\n            off(document, ['mousemove', 'touchmove'], this._delayedTapMove, {passive: false});\n\n            if (this._emitEvent('beforedrag', evt) === false) {\n                off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n                return;\n            }\n\n            on(document, ['mousemove', 'touchmove'], this._onTapMove, {passive: false});\n\n            // Make area element visible\n            css(this._area, 'display', 'block');\n\n            // Append selection-area to the dom\n            selectAll(container, document)[0].appendChild(this._clippingElement);\n\n            this.resolveSelectables();\n\n            // An action is recognized as single-select until the user performed a multi-selection\n            this._singleClick = false;\n\n            // Just saving the boundaries of this container for later\n            this._targetRect = this._targetElement!.getBoundingClientRect();\n\n            // Find container and check if it's scrollable\n            this._scrollAvailable =\n                this._targetElement!.scrollHeight !== this._targetElement!.clientHeight ||\n                this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\n\n            if (this._scrollAvailable) {\n\n                // Detect mouse scrolling\n                on(document, 'wheel', this._manualScroll, {passive: false});\n\n                /**\n                 * The selection-area will also cover other element which are\n                 * out of the current scrollable parent. So find all elements\n                 * which are in the current scrollable element. Later these are\n                 * the only selectables instead of all.\n                 */\n                this._selectables = this._selectables.filter(s => this._targetElement!.contains(s));\n            }\n\n            // Re-setup selection area and fire event\n            this._setupSelectionArea();\n            this._emitEvent('start', evt);\n            this._onTapMove(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _setupSelectionArea(): void {\n        const {_clippingElement, _targetElement, _area} = this;\n        const tr = this._targetRect = _targetElement!.getBoundingClientRect();\n\n        if (this._scrollAvailable) {\n\n            /**\n             * To clip the area, the selection area has a parent\n             * which has exact the same dimensions as the scrollable element.\n             * Now if the area exceeds these boundaries it will be cropped.\n             */\n            css(_clippingElement, {\n                top: tr.top,\n                left: tr.left,\n                width: tr.width,\n                height: tr.height\n            });\n\n            /**\n             * The area element is relative to the clipping element,\n             * but when this is moved or transformed we need to correct\n             * the positions via a negative margin.\n             */\n            css(_area, {\n                marginTop: -tr.top,\n                marginLeft: -tr.left\n            });\n        } else {\n\n            // \"Reset\" styles\n            css(_clippingElement, {\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%'\n            });\n\n            css(_area, {\n                marginTop: 0,\n                marginLeft: 0\n            });\n        }\n    }\n\n    _onTapMove(evt: MouseEvent | TouchEvent): void {\n        const {x, y} = simplifyEvent(evt);\n        const {_scrollSpeed, _areaLocation, _options, _frame} = this;\n        const {speedDivider} = _options.behaviour.scrolling;\n        const _targetElement = this._targetElement as Element;\n\n        _areaLocation.x2 = x;\n        _areaLocation.y2 = y;\n\n        if (this._scrollAvailable && !this._scrollingActive && (_scrollSpeed.y || _scrollSpeed.x)) {\n\n            // Continuous scrolling\n            this._scrollingActive = true;\n\n            const scroll = () => {\n                if (!_scrollSpeed.x && !_scrollSpeed.y) {\n                    this._scrollingActive = false;\n                    return;\n                }\n\n                // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\n                const {scrollTop, scrollLeft} = _targetElement;\n\n                if (_scrollSpeed.y) {\n                    _targetElement.scrollTop += ceil(_scrollSpeed.y / speedDivider);\n                    _areaLocation.y1 -= _targetElement.scrollTop - scrollTop;\n                }\n\n                if (_scrollSpeed.x) {\n                    _targetElement.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\n                    _areaLocation.x1 -= _targetElement.scrollLeft - scrollLeft;\n                }\n\n                /**\n                 * We changed the start coordinates -> redraw the selection-area\n                 * We changed the dimensions of the area element -> re-calc selected elements\n                 * The selected elements array has been changed -> fire event\n                 */\n                _frame.next(evt);\n\n                // Keep scrolling even if the user stops to move his pointer\n                requestAnimationFrame(scroll);\n            };\n\n            requestAnimationFrame(scroll);\n        } else {\n\n            /**\n             * Perform redraw only if scrolling is not active.\n             * If scrolling is active this area is getting re-dragged by the\n             * anonymize scroll function.\n             */\n            _frame.next(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _handleMoveEvent(evt: MouseEvent | TouchEvent) {\n        const {features} = this._options;\n\n        /**\n         * - Prevent auto-refresh for when pulling down on touch devices.\n         * - Prevent auto-scroll by the browser when on safari and scrolling is handled by viselect.\n         */\n        if ((features.touch && isTouchDevice()) || (this._scrollAvailable && isSafariBrowser())) {\n            evt.preventDefault(); // Prevent swipe-down refresh\n        }\n    }\n\n    _onScroll(): void {\n        const {_scrollDelta, _options: {document}} = this;\n        const {scrollTop, scrollLeft} = document.scrollingElement || document.body;\n\n        // Adjust area start location\n        this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\n        this._areaLocation.y1 += _scrollDelta.y - scrollTop;\n        _scrollDelta.x = scrollLeft;\n        _scrollDelta.y = scrollTop;\n\n        // The area needs to be set back as the target-container has changed in its position\n        this._setupSelectionArea();\n        this._frame.next(null);\n    }\n\n    _manualScroll(evt: ScrollEvent): void {\n        const {manualSpeed} = this._options.behaviour.scrolling;\n\n        // Consistent scrolling speed on all browsers\n        const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\n        const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\n        this._scrollSpeed.y += deltaY * manualSpeed;\n        this._scrollSpeed.x += deltaX * manualSpeed;\n        this._onTapMove(evt);\n\n        // Prevent default scrolling behaviour, e.g. page scrolling\n        evt.preventDefault();\n    }\n\n    _recalculateSelectionAreaRect(): void {\n        const {_scrollSpeed, _areaLocation, _areaRect, _targetElement, _options} = this;\n        const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = _targetElement as Element;\n        const _targetRect = this._targetRect as DOMRect;\n\n        const {x1, y1} = _areaLocation;\n        let {x2, y2} = _areaLocation;\n\n        const {behaviour: {scrolling: {startScrollMargins}}} = _options;\n\n        if (x2 < _targetRect.left + startScrollMargins.x) {\n            _scrollSpeed.x = scrollLeft ? -abs(_targetRect.left - x2 + startScrollMargins.x) : 0;\n            x2 = x2 < _targetRect.left ? _targetRect.left : x2;\n        } else if (x2 > _targetRect.right - startScrollMargins.x) {\n            _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(_targetRect.left + _targetRect.width - x2 - startScrollMargins.x) : 0;\n            x2 = x2 > _targetRect.right ? _targetRect.right : x2;\n        } else {\n            _scrollSpeed.x = 0;\n        }\n\n        if (y2 < _targetRect.top + startScrollMargins.y) {\n            _scrollSpeed.y = scrollTop ? -abs(_targetRect.top - y2 + startScrollMargins.y) : 0;\n            y2 = y2 < _targetRect.top ? _targetRect.top : y2;\n        } else if (y2 > _targetRect.bottom - startScrollMargins.y) {\n            _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(_targetRect.top + _targetRect.height - y2 - startScrollMargins.y) : 0;\n            y2 = y2 > _targetRect.bottom ? _targetRect.bottom : y2;\n        } else {\n            _scrollSpeed.y = 0;\n        }\n\n        const x3 = min(x1, x2);\n        const y3 = min(y1, y2);\n        const x4 = max(x1, x2);\n        const y4 = max(y1, y2);\n\n        _areaRect.x = x3;\n        _areaRect.y = y3;\n        _areaRect.width = x4 - x3;\n        _areaRect.height = y4 - y3;\n    }\n\n    _redrawSelectionArea(): void {\n        const {x, y, width, height} = this._areaRect;\n        const {style} = this._area;\n\n        // Using transform will make the area's borders look blurry\n        style.left = `${x}px`;\n        style.top = `${y}px`;\n        style.width = `${width}px`;\n        style.height = `${height}px`;\n    }\n\n    _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\n        const {document, features} = this._options;\n        const {_singleClick} = this;\n\n        // Remove event handlers\n        off(document, ['mousemove', 'touchmove'], this._delayedTapMove);\n        off(document, ['touchmove', 'mousemove'], this._onTapMove);\n        off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        off(document, 'scroll', this._onScroll);\n\n        // Keep selection until the next time\n        this._keepSelection();\n\n        if (evt && _singleClick && features.singleTap.allow) {\n            this._onSingleTap(evt);\n        } else if (!_singleClick && !silent) {\n            this._updateElementSelection();\n            this._emitEvent('stop', evt);\n        }\n\n        this._scrollSpeed.x = 0;\n        this._scrollSpeed.y = 0;\n\n        // Unbind mouse scrolling listener\n        this._scrollAvailable && off(document, 'wheel', this._manualScroll, {passive: true});\n\n        // Remove selection-area from dom\n        this._clippingElement.remove();\n\n        // Cancel current frame\n        this._frame?.cancel();\n\n        // Hide selection area\n        css(this._area, 'display', 'none');\n    }\n\n    _updateElementSelection(): void {\n        const {_selectables, _options, _selection, _areaRect} = this;\n        const {stored, selected, touched} = _selection;\n        const {intersect, overlap} = _options.behaviour;\n\n        const invert = overlap === 'invert';\n        const newlyTouched: Element[] = [];\n        const added: Element[] = [];\n        const removed: Element[] = [];\n\n        // Find newly selected elements\n        for (let i = 0; i < _selectables.length; i++) {\n            const node = _selectables[i];\n\n            // Check if area intersects element\n            if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\n\n                // Check if the element wasn't present in the last selection.\n                if (!selected.includes(node)) {\n\n                    // Check if user wants to invert the selection for already selected elements\n                    if (invert && stored.includes(node)) {\n                        removed.push(node);\n                        continue;\n                    } else {\n                        added.push(node);\n                    }\n                } else if (stored.includes(node) && !touched.includes(node)) {\n                    touched.push(node);\n                }\n\n                newlyTouched.push(node);\n            }\n        }\n\n        // Re-select elements which were previously stored\n        if (invert) {\n            added.push(...stored.filter(v => !selected.includes(v)));\n        }\n\n        // Check which elements where removed since last selection\n        const keep = overlap === 'keep';\n        for (let i = 0; i < selected.length; i++) {\n            const node = selected[i];\n\n            if (!newlyTouched.includes(node) && !(\n\n                // Check if user wants to keep previously selected elements, e.g.\n                // not make them part of the current selection as soon as they're touched.\n                keep && stored.includes(node)\n            )) {\n                removed.push(node);\n            }\n        }\n\n        _selection.selected = newlyTouched;\n        _selection.changed = {added, removed};\n        this._latestElement = newlyTouched[newlyTouched.length - 1];\n    }\n\n    _emitEvent(name: keyof SelectionEvents, evt: MouseEvent | TouchEvent | null): unknown {\n        return this.emit(name, {\n            event: evt,\n            store: this._selection,\n            selection: this\n        });\n    }\n\n    _keepSelection(): void {\n        const {_options, _selection} = this;\n        const {selected, changed, touched, stored} = _selection;\n        const addedElements = selected.filter(el => !stored.includes(el));\n\n        switch (_options.behaviour.overlap) {\n            case 'drop': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !touched.includes(el))  // Elements not touched\n                ];\n                break;\n            }\n            case 'invert': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !changed.removed.includes(el))  // Elements not removed from selection\n                ];\n                break;\n            }\n            case 'keep': {\n                _selection.stored = [\n                    ...stored,\n                    ...selected.filter(el => !stored.includes(el)) // Newly added\n                ];\n                break;\n            }\n        }\n    }\n\n    /**\n     * Manually triggers the start of a selection\n     * @param evt A MouseEvent / TouchEvent -like object\n     * @param silent If beforestart should be fired,\n     */\n    trigger(evt: MouseEvent | TouchEvent, silent = true): void {\n        this._onTapStart(evt, silent);\n    }\n\n    /**\n     * Can be used if during a selection elements have been added.\n     * Will update everything which can be selected.\n     */\n    resolveSelectables(): void {\n        this._selectables = selectAll(this._options.selectables, this._options.document);\n    }\n\n    /**\n     * Same as deselect, but for all elements currently selected.\n     * @param includeStored If the store should also get cleared\n     * @param quiet If move / stop events should be fired\n     */\n    clearSelection(includeStored = true, quiet = false): void {\n        const {selected, stored, changed} = this._selection;\n\n        changed.added = [];\n        changed.removed.push(\n            ...selected,\n            ...(includeStored ? stored : [])\n        );\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        // Reset state\n        this._latestElement = undefined;\n        this._selection = {\n            stored: includeStored ? [] : stored,\n            selected: [],\n            touched: [],\n            changed: {added: [], removed: []}\n        };\n    }\n\n    /**\n     * @returns {Array} Selected elements\n     */\n    getSelection(): Element[] {\n        return this._selection.stored;\n    }\n\n    /**\n     * @returns {HTMLElement} The selection area element\n     */\n    getSelectionArea(): HTMLElement {\n        return this._area;\n    }\n\n    /**\n     * Cancel the current selection process.\n     * @param keepEvent {boolean} true to fire a stop event after cancel.\n     */\n    cancel(keepEvent = false): void {\n        this._onTapStop(null, !keepEvent);\n    }\n\n    /**\n     * Unbinds all events and removes the area-element.\n     */\n    destroy(): void {\n        this.cancel();\n        this.disable();\n        this._clippingElement.remove();\n        super.unbindAllListeners();\n    }\n\n    /* eslint-disable no-invalid-this */\n    disable = this._bindStartEvents.bind(this, false);\n    enable = this._bindStartEvents;\n\n    /**\n     * Adds elements to the selection\n     * @param query - CSS Query, can be an array of queries\n     * @param quiet - If this should not trigger the move event\n     */\n    select(query: SelectAllSelectors, quiet = false): Element[] {\n        const {changed, selected, stored} = this._selection;\n        const elements = selectAll(query, this._options.document).filter(el =>\n            !selected.includes(el) &&\n            !stored.includes(el)\n        );\n\n        // Update element lists\n        stored.push(...elements);\n        selected.push(...elements);\n        changed.added.push(...elements);\n        changed.removed = [];\n\n        // We don't know which element was \"selected\" first so clear it\n        this._latestElement = undefined;\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        return elements;\n    }\n\n    /**\n     * Removes a particular element from the selection.\n     * @param query - CSS Query, can be an array of queries\n     * @param quiet - If this should not trigger the move event\n     */\n    deselect(query: SelectAllSelectors, quiet = false) {\n        const {selected, stored, changed} = this._selection;\n\n        const elements = selectAll(query, this._options.document).filter(el =>\n            selected.includes(el) ||\n            stored.includes(el)\n        );\n\n        if (!elements.length) {\n            return;\n        }\n\n        this._selection.stored = stored.filter(el => !elements.includes(el));\n        this._selection.selected = selected.filter(el => !elements.includes(el));\n        this._selection.changed.added = [];\n        this._selection.changed.removed.push(\n            ...elements.filter(el => !changed.removed.includes(el))\n        );\n\n        // We don't know which element was \"selected\" first so clear it\n        this._latestElement = undefined;\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n    }\n}\n"],"names":["EventTarget","__publicField","event","cb","set","_a","data","ok","unitify","val","unit","css","style","attr","key","value","eventListener","method","items","events","fn","options","el","ev","on","off","simplifyEvent","evt","clientX","clientY","target","intersects","a","b","mode","bxc","byc","selectAll","selector","doc","list","nodes","i","l","item","isTouchDevice","isSafariBrowser","deepAssign","source","sourceValue","frames","previousArgs","frameId","lock","args","abs","max","min","ceil","SelectionArea","opt","document","selectionAreaClass","selectionContainerClass","activate","features","silent","x","y","_options","targetBoundingClientRect","startAreas","resolvedBoundaries","evtPath","scrollElement","intersect","range","e","v","right","left","top","bottom","stored","reference","preceding","following","rangeItems","container","startThreshold","x1","y1","thresholdType","s","_clippingElement","_targetElement","_area","tr","_scrollSpeed","_areaLocation","_frame","speedDivider","scroll","scrollTop","scrollLeft","_scrollDelta","manualSpeed","deltaY","deltaX","_areaRect","scrollHeight","clientHeight","scrollWidth","clientWidth","_targetRect","x2","y2","startScrollMargins","x3","y3","x4","y4","width","height","_singleClick","_selectables","_selection","selected","touched","overlap","invert","newlyTouched","added","removed","node","keep","name","changed","addedElements","includeStored","quiet","keepEvent","query","elements"],"mappings":"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"}