"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BlockSelectable: () => BlockSelectable,
  BlockSelectionArea: () => BlockSelectionArea,
  BlockStartArea: () => BlockStartArea,
  KEY_BLOCK_SELECTION: () => KEY_BLOCK_SELECTION,
  SelectionArea: () => SelectionArea,
  blockSelectionActions: () => blockSelectionActions,
  blockSelectionSelectors: () => blockSelectionSelectors,
  blockSelectionStore: () => blockSelectionStore,
  copySelectedBlocks: () => copySelectedBlocks,
  createBlockSelectionPlugin: () => createBlockSelectionPlugin,
  extractSelectableIds: () => extractSelectableIds,
  getSelectedBlocks: () => getSelectedBlocks,
  onChangeBlockSelection: () => onChangeBlockSelection,
  pasteSelectedBlocks: () => pasteSelectedBlocks,
  selectInsertedBlocks: () => selectInsertedBlocks,
  useBlockSelectable: () => useBlockSelectable,
  useBlockSelectableState: () => useBlockSelectableState,
  useBlockSelectionArea: () => useBlockSelectionArea,
  useBlockSelectionSelectors: () => useBlockSelectionSelectors,
  useBlockStartArea: () => useBlockStartArea,
  useHooksBlockSelection: () => useHooksBlockSelection
});
module.exports = __toCommonJS(src_exports);

// src/blockSelectionStore.ts
var import_server = require("@udecode/plate-common/server");

// src/utils/extractSelectableIds.ts
var extractSelectableIds = (els) => {
  return els.map((v) => v.dataset.key);
};

// src/blockSelectionStore.ts
var blockSelectionStore = (0, import_server.createZustandStore)("selection")({
  isSelecting: false,
  selectedIds: /* @__PURE__ */ new Set()
}).extendActions((set, get) => ({
  resetSelectedIds: () => {
    set.selectedIds(/* @__PURE__ */ new Set());
  },
  setSelectedIds: ({ added, removed }) => {
    const prev = get.selectedIds();
    const next = new Set(prev);
    extractSelectableIds(added).forEach((id) => next.add(id));
    extractSelectableIds(removed).forEach((id) => next.delete(id));
    set.selectedIds(next);
    set.isSelecting(true);
  },
  unselect: () => {
    set.selectedIds(/* @__PURE__ */ new Set());
    set.isSelecting(false);
  }
})).extendSelectors((set, get) => ({
  isSelected: (id) => id && get.selectedIds().has(id),
  isSelectingSome: () => get.selectedIds().size > 0
}));
var useBlockSelectionSelectors = () => blockSelectionStore.use;
var blockSelectionSelectors = blockSelectionStore.get;
var blockSelectionActions = blockSelectionStore.set;

// src/createBlockSelectionPlugin.tsx
var import_react5 = __toESM(require("react"));
var import_server8 = require("@udecode/plate-common/server");

// src/components/BlockSelectable.tsx
var import_react = __toESM(require("react"));
var import_plate_common = require("@udecode/plate-common");
var import_server2 = require("@udecode/plate-common/server");
var useBlockSelectableState = ({
  active,
  element,
  selectedColor
}) => {
  const editor = (0, import_plate_common.useEditorRef)();
  const path = import_react.default.useMemo(
    () => (0, import_plate_common.findNodePath)(editor, element),
    [editor, element]
  );
  if (!path || (0, import_server2.isInline)(editor, element)) {
    return {
      active: active != null ? active : false
    };
  }
  const { query } = (0, import_server2.getPluginOptions)(
    editor,
    KEY_BLOCK_SELECTION
  );
  if (query && !(0, import_server2.queryNode)([element, path], query)) {
    return {
      active: active != null ? active : false
    };
  }
  return {
    active: active != null ? active : true,
    element,
    selectedColor
  };
};
var useBlockSelectable = ({
  element,
  selectedColor
}) => {
  const id = element == null ? void 0 : element.id;
  const isSelected = useBlockSelectionSelectors().isSelected(id);
  const data = {
    "data-key": id
  };
  return {
    props: __spreadValues({
      className: isSelected ? "slate-selected slate-selectable" : "slate-selectable",
      key: id,
      style: isSelected ? {
        backgroundColor: selectedColor
      } : void 0
    }, data)
  };
};
function BlockSelectable(_a) {
  var _b = _a, {
    children,
    options
  } = _b, props = __objRest(_b, [
    "children",
    "options"
  ]);
  const state = useBlockSelectableState(options);
  const { props: rootProps } = useBlockSelectable(state);
  if (!state.active)
    return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, children);
  return /* @__PURE__ */ import_react.default.createElement("div", __spreadValues(__spreadValues({}, rootProps), props), children);
}

// src/components/BlockSelectionArea.tsx
var import_react3 = __toESM(require("react"));
var import_plate_common2 = require("@udecode/plate-common");

// src/components/SelectionArea.tsx
var import_react2 = __toESM(require("react"));
var import_vanilla = __toESM(require("@viselect/vanilla"));
function SelectionArea(_a) {
  var _b = _a, {
    behaviour,
    children,
    container,
    document: document2,
    features,
    getBoundaries = (boundaries) => boundaries,
    onBeforeStart,
    onMove,
    onStart,
    onStop,
    selectables,
    selectionAreaClass,
    selectionContainerClass,
    startAreas
  } = _b, props = __objRest(_b, [
    "behaviour",
    "children",
    "container",
    "document",
    "features",
    "getBoundaries",
    "onBeforeStart",
    "onMove",
    "onStart",
    "onStop",
    "selectables",
    "selectionAreaClass",
    "selectionContainerClass",
    "startAreas"
  ]);
  const ref = import_react2.default.createRef();
  import_react2.default.useEffect(() => {
    const opt = {
      behaviour,
      container,
      document: document2,
      features,
      selectables,
      selectionAreaClass,
      selectionContainerClass,
      startAreas
    };
    const areaBoundaries = ref.current;
    const selection = new import_vanilla.default(__spreadValues({
      boundaries: getBoundaries(areaBoundaries)
    }, opt));
    onBeforeStart && selection.on("beforestart", onBeforeStart);
    onStart && selection.on("start", onStart);
    onMove && selection.on("move", onMove);
    onStop && selection.on("stop", onStop);
    return () => selection.destroy();
  }, []);
  return /* @__PURE__ */ import_react2.default.createElement("div", __spreadValues({ ref }, props), children);
}

// src/components/BlockSelectionArea.tsx
var useBlockSelectionArea = (props) => {
  const editor = (0, import_plate_common2.useEditorRef)();
  const onStart = ({ event, selection }) => {
    (0, import_plate_common2.deselectEditor)(editor);
    if (!(event == null ? void 0 : event.shiftKey)) {
      selection.clearSelection();
      blockSelectionActions.resetSelectedIds();
    }
  };
  const onMove = ({ store: { changed } }) => {
    if (changed.added.length === 0 && changed.removed.length === 0)
      return;
    blockSelectionActions.setSelectedIds(changed);
  };
  return __spreadValues({
    className: "slate-SelectionArea",
    onMove,
    onStart,
    // Query selectors for elements which can be selected.
    selectables: ".slate-selectable",
    // Class for the selection-area itself (the element).
    selectionAreaClass: "slate-selection-area",
    // Class for the selection-area container.
    // selectionContainerClass="selection-area-container"
    // Query selector or dom-node to set up container for the selection-area element.
    // container="body"
    // document object - if you want to use it within an embed document (or iframe).
    // document={window.document}
    // Query selectors for elements from where a selection can be started from.
    startAreas: ".slate-start-area",
    style: {
      position: "relative",
      width: "100%"
    }
  }, props);
};
function BlockSelectionArea(props) {
  const componentProps = useBlockSelectionArea(props);
  return /* @__PURE__ */ import_react3.default.createElement(SelectionArea, __spreadValues({}, componentProps));
}

// src/components/BlockStartArea.tsx
var import_plate_common3 = require("@udecode/plate-common");
var useBlockStartArea = ({
  placement = "left",
  size = "auto"
}) => {
  return {
    props: {
      className: `slate-start-area slate-start-area-${placement}`,
      style: {
        bottom: ["bottom"].includes(placement) ? 0 : void 0,
        cursor: "text",
        height: ["bottom", "top"].includes(placement) ? size : "100%",
        left: ["bottom", "left", "top"].includes(placement) ? 0 : void 0,
        position: "absolute",
        right: ["right"].includes(placement) ? 0 : void 0,
        top: ["left", "right", "top"].includes(placement) ? 0 : void 0,
        userSelect: "none",
        width: ["left", "right"].includes(placement) ? size : "100%",
        zIndex: 1
      }
    }
  };
};
var BlockStartArea = (0, import_plate_common3.createPrimitiveComponent)("div")({
  propsHook: useBlockStartArea
});

// src/onChangeBlockSelection.ts
var onChangeBlockSelection = (editor) => () => {
  if (editor.selection && blockSelectionSelectors.isSelecting()) {
    blockSelectionActions.unselect();
  }
};

// src/useHooksBlockSelection.ts
var import_react4 = __toESM(require("react"));
var import_plate_common5 = require("@udecode/plate-common");
var import_server7 = require("@udecode/plate-common/server");

// src/utils/copySelectedBlocks.ts
var import_server4 = require("@udecode/plate-common/server");
var import_copy_to_clipboard = __toESM(require("copy-to-clipboard"));

// src/queries/getSelectedBlocks.ts
var import_server3 = require("@udecode/plate-common/server");
var getSelectedBlocks = (editor) => {
  const selectedIds = blockSelectionSelectors.selectedIds();
  return [
    ...(0, import_server3.getNodeEntries)(editor, {
      at: [],
      match: (n) => selectedIds.has(n.id)
    })
  ];
};

// src/utils/copySelectedBlocks.ts
var copySelectedBlocks = (editor) => {
  const selectedIds = blockSelectionSelectors.selectedIds();
  const selectedEntries = getSelectedBlocks(editor);
  const selectedFragment = selectedEntries.map(([node]) => node);
  (0, import_copy_to_clipboard.default)(" ", {
    onCopy: (dataTransfer) => {
      const data = dataTransfer;
      if (!data)
        return;
      let textPlain = "";
      const div = document.createElement("div");
      (0, import_server4.withoutNormalizing)(editor, () => {
        selectedEntries.forEach(([, path]) => {
          (0, import_server4.select)(editor, {
            anchor: (0, import_server4.getStartPoint)(editor, path),
            focus: (0, import_server4.getEndPoint)(editor, path)
          });
          editor.setFragmentData(data);
          textPlain += `${data.getData("text/plain")}
`;
          const divChild = document.createElement("div");
          divChild.innerHTML = data.getData("text/html");
          div.append(divChild);
        });
        (0, import_server4.deselect)(editor);
        blockSelectionActions.selectedIds(selectedIds);
      });
      data.setData("text/plain", textPlain);
      data.setData("text/html", div.innerHTML);
      const selectedFragmentStr = JSON.stringify(selectedFragment);
      const encodedFragment = window.btoa(
        encodeURIComponent(selectedFragmentStr)
      );
      data.setData("application/x-slate-fragment", encodedFragment);
    }
  });
};

// src/utils/pasteSelectedBlocks.ts
var import_plate_common4 = require("@udecode/plate-common");
var import_server6 = require("@udecode/plate-common/server");
var import_slate = require("slate");

// src/utils/selectInsertedBlocks.ts
var import_server5 = require("@udecode/plate-common/server");
var selectInsertedBlocks = (editor) => {
  const ids = /* @__PURE__ */ new Set();
  editor.operations.forEach((op) => {
    if (op.type === "insert_node" && op.node.id && (0, import_server5.isBlock)(editor, op.node)) {
      ids.add(op.node.id);
    }
  });
  setTimeout(() => {
    blockSelectionActions.isSelecting(true);
    blockSelectionActions.selectedIds(ids);
  }, 0);
};

// src/utils/pasteSelectedBlocks.ts
var pasteSelectedBlocks = (editor, e) => {
  const entries = getSelectedBlocks(editor);
  if (entries.length > 0) {
    const entry = entries.at(-1);
    const [node, path] = entry;
    (0, import_plate_common4.focusEditor)(editor, (0, import_server6.getStartPoint)(editor, path));
    if (!(0, import_server6.isElementEmpty)(editor, node)) {
      const at = import_slate.Path.next(path);
      (0, import_server6.insertNodes)(editor, editor.blockFactory({}, at), {
        at,
        select: true
      });
    }
    (0, import_plate_common4.insertData)(editor, e.clipboardData);
    (0, import_server6.deselect)(editor);
    selectInsertedBlocks(editor);
  }
};

// src/useHooksBlockSelection.ts
var useHooksBlockSelection = (editor, { options }) => {
  const { onKeyDownSelecting } = options;
  const isSelecting = useBlockSelectionSelectors().isSelecting();
  const selectedIds = useBlockSelectionSelectors().selectedIds();
  import_react4.default.useEffect(() => {
    const el = document.querySelector("#slate-shadow-input");
    if (el) {
      el.remove();
    }
    const isReadonly = (0, import_plate_common5.isEditorReadOnly)(editor);
    if (isSelecting) {
      const input = document.createElement("input");
      input.setAttribute("id", "slate-shadow-input");
      input.style.position = "fixed";
      input.style.zIndex = "10000";
      input.style.top = "-300px";
      input.style.left = "-300px";
      input.style.opacity = "0";
      input.addEventListener("keydown", (e) => {
        onKeyDownSelecting == null ? void 0 : onKeyDownSelecting(e);
        if (!blockSelectionSelectors.isSelecting())
          return;
        if ((0, import_server7.isHotkey)("escape")(e)) {
          blockSelectionActions.unselect();
        }
        if ((0, import_server7.isHotkey)("mod+z")(e)) {
          editor.undo();
          selectInsertedBlocks(editor);
        }
        if ((0, import_server7.isHotkey)("mod+shift+z")(e)) {
          editor.redo();
          selectInsertedBlocks(editor);
        }
        if (!blockSelectionSelectors.isSelectingSome())
          return;
        if ((0, import_server7.isHotkey)("enter")(e)) {
          const entry = (0, import_server7.findNode)(editor, {
            match: (n) => blockSelectionSelectors.selectedIds().has(n.id)
          });
          if (entry) {
            const [, path] = entry;
            (0, import_plate_common5.focusEditor)(editor, (0, import_server7.getEndPoint)(editor, path));
            e.preventDefault();
          }
        }
        if ((0, import_server7.isHotkey)(["backspace", "delete"])(e) && !isReadonly) {
          (0, import_server7.removeNodes)(editor, {
            at: [],
            match: (n) => blockSelectionSelectors.selectedIds().has(n.id)
          });
        }
      });
      input.addEventListener("copy", (e) => {
        e.preventDefault();
        if (blockSelectionSelectors.isSelectingSome()) {
          copySelectedBlocks(editor);
        }
      });
      input.addEventListener("cut", (e) => {
        e.preventDefault();
        if (blockSelectionSelectors.isSelectingSome()) {
          copySelectedBlocks(editor);
          if (!isReadonly) {
            (0, import_server7.removeNodes)(editor, {
              at: [],
              match: (n) => blockSelectionSelectors.selectedIds().has(n.id)
            });
          }
        }
      });
      input.addEventListener("paste", (e) => {
        e.preventDefault();
        if (!isReadonly) {
          pasteSelectedBlocks(editor, e);
        }
      });
      document.body.append(input);
      input.focus();
    }
  }, [editor, isSelecting, onKeyDownSelecting, selectedIds]);
};

// src/createBlockSelectionPlugin.tsx
var KEY_BLOCK_SELECTION = "blockSelection";
var createBlockSelectionPlugin = (0, import_server8.createPluginFactory)({
  handlers: {
    onChange: onChangeBlockSelection
  },
  inject: {
    aboveComponent: () => ({ children, element }) => BlockSelectable({
      children,
      options: {
        element,
        selectedColor: "rgb(219 234 254)"
      }
    })
  },
  key: KEY_BLOCK_SELECTION,
  options: {
    query: {
      maxLevel: 1
    },
    sizes: {
      bottom: 4,
      left: 4,
      right: 4,
      top: 4
    }
  },
  then: (editor, { options }) => ({
    renderAboveEditable: ({ children }) => {
      var _a, _b, _c, _d;
      return /* @__PURE__ */ import_react5.default.createElement(BlockSelectionArea, null, /* @__PURE__ */ import_react5.default.createElement(
        BlockStartArea,
        {
          state: {
            placement: "left",
            size: (_a = options.sizes) == null ? void 0 : _a.left
          }
        }
      ), /* @__PURE__ */ import_react5.default.createElement(
        BlockStartArea,
        {
          state: {
            placement: "top",
            size: (_b = options.sizes) == null ? void 0 : _b.top
          }
        }
      ), /* @__PURE__ */ import_react5.default.createElement(
        BlockStartArea,
        {
          state: {
            placement: "right",
            size: (_c = options.sizes) == null ? void 0 : _c.right
          }
        }
      ), /* @__PURE__ */ import_react5.default.createElement(
        BlockStartArea,
        {
          state: {
            placement: "bottom",
            size: (_d = options.sizes) == null ? void 0 : _d.bottom
          }
        }
      ), children);
    }
  }),
  useHooks: useHooksBlockSelection
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BlockSelectable,
  BlockSelectionArea,
  BlockStartArea,
  KEY_BLOCK_SELECTION,
  SelectionArea,
  blockSelectionActions,
  blockSelectionSelectors,
  blockSelectionStore,
  copySelectedBlocks,
  createBlockSelectionPlugin,
  extractSelectableIds,
  getSelectedBlocks,
  onChangeBlockSelection,
  pasteSelectedBlocks,
  selectInsertedBlocks,
  useBlockSelectable,
  useBlockSelectableState,
  useBlockSelectionArea,
  useBlockSelectionSelectors,
  useBlockStartArea,
  useHooksBlockSelection
});
//# sourceMappingURL=index.js.map