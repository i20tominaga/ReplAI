var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/blockSelectionStore.ts
import { createZustandStore } from "@udecode/plate-common/server";

// src/utils/extractSelectableIds.ts
var extractSelectableIds = (els) => {
  return els.map((v) => v.dataset.key);
};

// src/blockSelectionStore.ts
var blockSelectionStore = createZustandStore("selection")({
  isSelecting: false,
  selectedIds: /* @__PURE__ */ new Set()
}).extendActions((set, get) => ({
  resetSelectedIds: () => {
    set.selectedIds(/* @__PURE__ */ new Set());
  },
  setSelectedIds: ({ added, removed }) => {
    const prev = get.selectedIds();
    const next = new Set(prev);
    extractSelectableIds(added).forEach((id) => next.add(id));
    extractSelectableIds(removed).forEach((id) => next.delete(id));
    set.selectedIds(next);
    set.isSelecting(true);
  },
  unselect: () => {
    set.selectedIds(/* @__PURE__ */ new Set());
    set.isSelecting(false);
  }
})).extendSelectors((set, get) => ({
  isSelected: (id) => id && get.selectedIds().has(id),
  isSelectingSome: () => get.selectedIds().size > 0
}));
var useBlockSelectionSelectors = () => blockSelectionStore.use;
var blockSelectionSelectors = blockSelectionStore.get;
var blockSelectionActions = blockSelectionStore.set;

// src/createBlockSelectionPlugin.tsx
import React5 from "react";
import {
  createPluginFactory
} from "@udecode/plate-common/server";

// src/components/BlockSelectable.tsx
import React from "react";
import { findNodePath, useEditorRef } from "@udecode/plate-common";
import {
  getPluginOptions,
  isInline,
  queryNode
} from "@udecode/plate-common/server";
var useBlockSelectableState = ({
  active,
  element,
  selectedColor
}) => {
  const editor = useEditorRef();
  const path = React.useMemo(
    () => findNodePath(editor, element),
    [editor, element]
  );
  if (!path || isInline(editor, element)) {
    return {
      active: active != null ? active : false
    };
  }
  const { query } = getPluginOptions(
    editor,
    KEY_BLOCK_SELECTION
  );
  if (query && !queryNode([element, path], query)) {
    return {
      active: active != null ? active : false
    };
  }
  return {
    active: active != null ? active : true,
    element,
    selectedColor
  };
};
var useBlockSelectable = ({
  element,
  selectedColor
}) => {
  const id = element == null ? void 0 : element.id;
  const isSelected = useBlockSelectionSelectors().isSelected(id);
  const data = {
    "data-key": id
  };
  return {
    props: __spreadValues({
      className: isSelected ? "slate-selected slate-selectable" : "slate-selectable",
      key: id,
      style: isSelected ? {
        backgroundColor: selectedColor
      } : void 0
    }, data)
  };
};
function BlockSelectable(_a) {
  var _b = _a, {
    children,
    options
  } = _b, props = __objRest(_b, [
    "children",
    "options"
  ]);
  const state = useBlockSelectableState(options);
  const { props: rootProps } = useBlockSelectable(state);
  if (!state.active)
    return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
  return /* @__PURE__ */ React.createElement("div", __spreadValues(__spreadValues({}, rootProps), props), children);
}

// src/components/BlockSelectionArea.tsx
import React3 from "react";
import { deselectEditor, useEditorRef as useEditorRef2 } from "@udecode/plate-common";

// src/components/SelectionArea.tsx
import React2 from "react";
import VanillaSelectionArea from "@viselect/vanilla";
function SelectionArea(_a) {
  var _b = _a, {
    behaviour,
    children,
    container,
    document: document2,
    features,
    getBoundaries = (boundaries) => boundaries,
    onBeforeStart,
    onMove,
    onStart,
    onStop,
    selectables,
    selectionAreaClass,
    selectionContainerClass,
    startAreas
  } = _b, props = __objRest(_b, [
    "behaviour",
    "children",
    "container",
    "document",
    "features",
    "getBoundaries",
    "onBeforeStart",
    "onMove",
    "onStart",
    "onStop",
    "selectables",
    "selectionAreaClass",
    "selectionContainerClass",
    "startAreas"
  ]);
  const ref = React2.createRef();
  React2.useEffect(() => {
    const opt = {
      behaviour,
      container,
      document: document2,
      features,
      selectables,
      selectionAreaClass,
      selectionContainerClass,
      startAreas
    };
    const areaBoundaries = ref.current;
    const selection = new VanillaSelectionArea(__spreadValues({
      boundaries: getBoundaries(areaBoundaries)
    }, opt));
    onBeforeStart && selection.on("beforestart", onBeforeStart);
    onStart && selection.on("start", onStart);
    onMove && selection.on("move", onMove);
    onStop && selection.on("stop", onStop);
    return () => selection.destroy();
  }, []);
  return /* @__PURE__ */ React2.createElement("div", __spreadValues({ ref }, props), children);
}

// src/components/BlockSelectionArea.tsx
var useBlockSelectionArea = (props) => {
  const editor = useEditorRef2();
  const onStart = ({ event, selection }) => {
    deselectEditor(editor);
    if (!(event == null ? void 0 : event.shiftKey)) {
      selection.clearSelection();
      blockSelectionActions.resetSelectedIds();
    }
  };
  const onMove = ({ store: { changed } }) => {
    if (changed.added.length === 0 && changed.removed.length === 0)
      return;
    blockSelectionActions.setSelectedIds(changed);
  };
  return __spreadValues({
    className: "slate-SelectionArea",
    onMove,
    onStart,
    // Query selectors for elements which can be selected.
    selectables: ".slate-selectable",
    // Class for the selection-area itself (the element).
    selectionAreaClass: "slate-selection-area",
    // Class for the selection-area container.
    // selectionContainerClass="selection-area-container"
    // Query selector or dom-node to set up container for the selection-area element.
    // container="body"
    // document object - if you want to use it within an embed document (or iframe).
    // document={window.document}
    // Query selectors for elements from where a selection can be started from.
    startAreas: ".slate-start-area",
    style: {
      position: "relative",
      width: "100%"
    }
  }, props);
};
function BlockSelectionArea(props) {
  const componentProps = useBlockSelectionArea(props);
  return /* @__PURE__ */ React3.createElement(SelectionArea, __spreadValues({}, componentProps));
}

// src/components/BlockStartArea.tsx
import { createPrimitiveComponent } from "@udecode/plate-common";
var useBlockStartArea = ({
  placement = "left",
  size = "auto"
}) => {
  return {
    props: {
      className: `slate-start-area slate-start-area-${placement}`,
      style: {
        bottom: ["bottom"].includes(placement) ? 0 : void 0,
        cursor: "text",
        height: ["bottom", "top"].includes(placement) ? size : "100%",
        left: ["bottom", "left", "top"].includes(placement) ? 0 : void 0,
        position: "absolute",
        right: ["right"].includes(placement) ? 0 : void 0,
        top: ["left", "right", "top"].includes(placement) ? 0 : void 0,
        userSelect: "none",
        width: ["left", "right"].includes(placement) ? size : "100%",
        zIndex: 1
      }
    }
  };
};
var BlockStartArea = createPrimitiveComponent("div")({
  propsHook: useBlockStartArea
});

// src/onChangeBlockSelection.ts
var onChangeBlockSelection = (editor) => () => {
  if (editor.selection && blockSelectionSelectors.isSelecting()) {
    blockSelectionActions.unselect();
  }
};

// src/useHooksBlockSelection.ts
import React4 from "react";
import { focusEditor as focusEditor2, isEditorReadOnly } from "@udecode/plate-common";
import {
  findNode,
  getEndPoint as getEndPoint2,
  isHotkey,
  removeNodes
} from "@udecode/plate-common/server";

// src/utils/copySelectedBlocks.ts
import {
  deselect,
  getEndPoint,
  getStartPoint,
  select,
  withoutNormalizing
} from "@udecode/plate-common/server";
import copyToClipboard from "copy-to-clipboard";

// src/queries/getSelectedBlocks.ts
import {
  getNodeEntries
} from "@udecode/plate-common/server";
var getSelectedBlocks = (editor) => {
  const selectedIds = blockSelectionSelectors.selectedIds();
  return [
    ...getNodeEntries(editor, {
      at: [],
      match: (n) => selectedIds.has(n.id)
    })
  ];
};

// src/utils/copySelectedBlocks.ts
var copySelectedBlocks = (editor) => {
  const selectedIds = blockSelectionSelectors.selectedIds();
  const selectedEntries = getSelectedBlocks(editor);
  const selectedFragment = selectedEntries.map(([node]) => node);
  copyToClipboard(" ", {
    onCopy: (dataTransfer) => {
      const data = dataTransfer;
      if (!data)
        return;
      let textPlain = "";
      const div = document.createElement("div");
      withoutNormalizing(editor, () => {
        selectedEntries.forEach(([, path]) => {
          select(editor, {
            anchor: getStartPoint(editor, path),
            focus: getEndPoint(editor, path)
          });
          editor.setFragmentData(data);
          textPlain += `${data.getData("text/plain")}
`;
          const divChild = document.createElement("div");
          divChild.innerHTML = data.getData("text/html");
          div.append(divChild);
        });
        deselect(editor);
        blockSelectionActions.selectedIds(selectedIds);
      });
      data.setData("text/plain", textPlain);
      data.setData("text/html", div.innerHTML);
      const selectedFragmentStr = JSON.stringify(selectedFragment);
      const encodedFragment = window.btoa(
        encodeURIComponent(selectedFragmentStr)
      );
      data.setData("application/x-slate-fragment", encodedFragment);
    }
  });
};

// src/utils/pasteSelectedBlocks.ts
import { focusEditor, insertData } from "@udecode/plate-common";
import {
  deselect as deselect2,
  getStartPoint as getStartPoint2,
  insertNodes,
  isElementEmpty
} from "@udecode/plate-common/server";
import { Path } from "slate";

// src/utils/selectInsertedBlocks.ts
import {
  isBlock
} from "@udecode/plate-common/server";
var selectInsertedBlocks = (editor) => {
  const ids = /* @__PURE__ */ new Set();
  editor.operations.forEach((op) => {
    if (op.type === "insert_node" && op.node.id && isBlock(editor, op.node)) {
      ids.add(op.node.id);
    }
  });
  setTimeout(() => {
    blockSelectionActions.isSelecting(true);
    blockSelectionActions.selectedIds(ids);
  }, 0);
};

// src/utils/pasteSelectedBlocks.ts
var pasteSelectedBlocks = (editor, e) => {
  const entries = getSelectedBlocks(editor);
  if (entries.length > 0) {
    const entry = entries.at(-1);
    const [node, path] = entry;
    focusEditor(editor, getStartPoint2(editor, path));
    if (!isElementEmpty(editor, node)) {
      const at = Path.next(path);
      insertNodes(editor, editor.blockFactory({}, at), {
        at,
        select: true
      });
    }
    insertData(editor, e.clipboardData);
    deselect2(editor);
    selectInsertedBlocks(editor);
  }
};

// src/useHooksBlockSelection.ts
var useHooksBlockSelection = (editor, { options }) => {
  const { onKeyDownSelecting } = options;
  const isSelecting = useBlockSelectionSelectors().isSelecting();
  const selectedIds = useBlockSelectionSelectors().selectedIds();
  React4.useEffect(() => {
    const el = document.querySelector("#slate-shadow-input");
    if (el) {
      el.remove();
    }
    const isReadonly = isEditorReadOnly(editor);
    if (isSelecting) {
      const input = document.createElement("input");
      input.setAttribute("id", "slate-shadow-input");
      input.style.position = "fixed";
      input.style.zIndex = "10000";
      input.style.top = "-300px";
      input.style.left = "-300px";
      input.style.opacity = "0";
      input.addEventListener("keydown", (e) => {
        onKeyDownSelecting == null ? void 0 : onKeyDownSelecting(e);
        if (!blockSelectionSelectors.isSelecting())
          return;
        if (isHotkey("escape")(e)) {
          blockSelectionActions.unselect();
        }
        if (isHotkey("mod+z")(e)) {
          editor.undo();
          selectInsertedBlocks(editor);
        }
        if (isHotkey("mod+shift+z")(e)) {
          editor.redo();
          selectInsertedBlocks(editor);
        }
        if (!blockSelectionSelectors.isSelectingSome())
          return;
        if (isHotkey("enter")(e)) {
          const entry = findNode(editor, {
            match: (n) => blockSelectionSelectors.selectedIds().has(n.id)
          });
          if (entry) {
            const [, path] = entry;
            focusEditor2(editor, getEndPoint2(editor, path));
            e.preventDefault();
          }
        }
        if (isHotkey(["backspace", "delete"])(e) && !isReadonly) {
          removeNodes(editor, {
            at: [],
            match: (n) => blockSelectionSelectors.selectedIds().has(n.id)
          });
        }
      });
      input.addEventListener("copy", (e) => {
        e.preventDefault();
        if (blockSelectionSelectors.isSelectingSome()) {
          copySelectedBlocks(editor);
        }
      });
      input.addEventListener("cut", (e) => {
        e.preventDefault();
        if (blockSelectionSelectors.isSelectingSome()) {
          copySelectedBlocks(editor);
          if (!isReadonly) {
            removeNodes(editor, {
              at: [],
              match: (n) => blockSelectionSelectors.selectedIds().has(n.id)
            });
          }
        }
      });
      input.addEventListener("paste", (e) => {
        e.preventDefault();
        if (!isReadonly) {
          pasteSelectedBlocks(editor, e);
        }
      });
      document.body.append(input);
      input.focus();
    }
  }, [editor, isSelecting, onKeyDownSelecting, selectedIds]);
};

// src/createBlockSelectionPlugin.tsx
var KEY_BLOCK_SELECTION = "blockSelection";
var createBlockSelectionPlugin = createPluginFactory({
  handlers: {
    onChange: onChangeBlockSelection
  },
  inject: {
    aboveComponent: () => ({ children, element }) => BlockSelectable({
      children,
      options: {
        element,
        selectedColor: "rgb(219 234 254)"
      }
    })
  },
  key: KEY_BLOCK_SELECTION,
  options: {
    query: {
      maxLevel: 1
    },
    sizes: {
      bottom: 4,
      left: 4,
      right: 4,
      top: 4
    }
  },
  then: (editor, { options }) => ({
    renderAboveEditable: ({ children }) => {
      var _a, _b, _c, _d;
      return /* @__PURE__ */ React5.createElement(BlockSelectionArea, null, /* @__PURE__ */ React5.createElement(
        BlockStartArea,
        {
          state: {
            placement: "left",
            size: (_a = options.sizes) == null ? void 0 : _a.left
          }
        }
      ), /* @__PURE__ */ React5.createElement(
        BlockStartArea,
        {
          state: {
            placement: "top",
            size: (_b = options.sizes) == null ? void 0 : _b.top
          }
        }
      ), /* @__PURE__ */ React5.createElement(
        BlockStartArea,
        {
          state: {
            placement: "right",
            size: (_c = options.sizes) == null ? void 0 : _c.right
          }
        }
      ), /* @__PURE__ */ React5.createElement(
        BlockStartArea,
        {
          state: {
            placement: "bottom",
            size: (_d = options.sizes) == null ? void 0 : _d.bottom
          }
        }
      ), children);
    }
  }),
  useHooks: useHooksBlockSelection
});
export {
  BlockSelectable,
  BlockSelectionArea,
  BlockStartArea,
  KEY_BLOCK_SELECTION,
  SelectionArea,
  blockSelectionActions,
  blockSelectionSelectors,
  blockSelectionStore,
  copySelectedBlocks,
  createBlockSelectionPlugin,
  extractSelectableIds,
  getSelectedBlocks,
  onChangeBlockSelection,
  pasteSelectedBlocks,
  selectInsertedBlocks,
  useBlockSelectable,
  useBlockSelectableState,
  useBlockSelectionArea,
  useBlockSelectionSelectors,
  useBlockStartArea,
  useHooksBlockSelection
};
//# sourceMappingURL=index.mjs.map