"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AGridSection: () => AGridSection,
  AIndexSearch: () => AIndexSearch,
  DEFAULT_FREQUENTLY_USED_EMOJI: () => DEFAULT_FREQUENTLY_USED_EMOJI,
  EMOJI_MAX_SEARCH_RESULT: () => EMOJI_MAX_SEARCH_RESULT,
  EMOJI_TRIGGER: () => EMOJI_TRIGGER,
  EmojiCategory: () => EmojiCategory,
  EmojiFloatingGrid: () => EmojiFloatingGrid,
  EmojiFloatingGridBuilder: () => EmojiFloatingGridBuilder,
  EmojiFloatingIndexSearch: () => EmojiFloatingIndexSearch,
  EmojiFloatingLibrary: () => EmojiFloatingLibrary,
  EmojiGridSectionWithRoot: () => EmojiGridSectionWithRoot,
  EmojiInlineIndexSearch: () => EmojiInlineIndexSearch,
  EmojiInlineLibrary: () => EmojiInlineLibrary,
  EmojiPickerState: () => EmojiPickerState,
  EmojiSettings: () => EmojiSettings,
  EmojiTriggeringController: () => EmojiTriggeringController,
  FrequentEmojiStorage: () => FrequentEmojiStorage,
  Grid: () => Grid,
  KEY_EMOJI: () => KEY_EMOJI,
  LocalStorage: () => LocalStorage,
  NUM_OF_CATEGORIES: () => NUM_OF_CATEGORIES,
  createEmojiPlugin: () => createEmojiPlugin,
  defaultCategories: () => defaultCategories,
  emojiTriggeringControllerOptions: () => emojiTriggeringControllerOptions,
  getEmojiOnInsert: () => getEmojiOnInsert,
  getEmojiOnSelectItem: () => getEmojiOnSelectItem,
  getFindTriggeringInput: () => getFindTriggeringInput,
  i18n: () => i18n,
  useEmojiComboboxState: () => useEmojiComboboxState,
  useEmojiDropdownMenuState: () => useEmojiDropdownMenuState,
  useEmojiPicker: () => useEmojiPicker,
  withEmoji: () => withEmoji
});
module.exports = __toCommonJS(src_exports);

// src/types.ts
var EmojiCategory = {
  Activity: "activity",
  Custom: "custom",
  Flags: "flags",
  Foods: "foods",
  Frequent: "frequent",
  Nature: "nature",
  Objects: "objects",
  People: "people",
  Places: "places",
  Symbols: "symbols"
};

// src/constants.ts
var KEY_EMOJI = "emoji";
var EMOJI_TRIGGER = ":";
var EMOJI_MAX_SEARCH_RESULT = 60;
var emojiTriggeringControllerOptions = {
  limitTriggeringChars: 2,
  trigger: EMOJI_TRIGGER
};
var defaultCategories = [
  EmojiCategory.People,
  EmojiCategory.Nature,
  EmojiCategory.Foods,
  EmojiCategory.Activity,
  EmojiCategory.Places,
  EmojiCategory.Objects,
  EmojiCategory.Symbols,
  EmojiCategory.Flags
];
var EmojiSettings = {
  buttonSize: {
    value: 36
  },
  categories: {
    value: void 0
  },
  perLine: {
    value: 8
  },
  showFrequent: {
    limit: 16,
    value: true
  }
};
var DEFAULT_FREQUENTLY_USED_EMOJI = {
  "+1": 1,
  clap: 1,
  grinning: 1,
  heart: 1,
  heart_eyes: 1,
  hugging_face: 1,
  joy: 1,
  kissing_heart: 1,
  laughing: 1,
  pray: 1,
  rocket: 1,
  scream: 1,
  see_no_evil: 1
};
var NUM_OF_CATEGORIES = Object.values(EmojiCategory).length;
var i18n = {
  categories: {
    activity: "Activity",
    custom: "Custom",
    flags: "Flags",
    foods: "Food & Drink",
    frequent: "Frequently used",
    nature: "Animals & Nature",
    objects: "Objects",
    people: "Smileys & People",
    places: "Travel & Places",
    symbols: "Symbols"
  },
  clear: "Clear",
  pick: "Pick an emoji...",
  search: "Search all emoji",
  searchNoResultsSubtitle: "That emoji couldn\u2019t be found",
  searchNoResultsTitle: "Oh no!",
  searchResult: "Search Results",
  skins: {
    "1": "Default",
    "2": "Light",
    "3": "Medium-Light",
    "4": "Medium",
    "5": "Medium-Dark",
    "6": "Dark",
    choose: "Choose default skin tone"
  }
};

// src/createEmojiPlugin.ts
var import_server5 = require("@udecode/plate-common/server");

// src/utils/EmojiTriggeringController.ts
var EmojiTriggeringController = class {
  constructor(options = emojiTriggeringControllerOptions) {
    this.options = options;
    this._hasTriggeringMark = false;
    this._isTriggering = false;
    this.text = "";
  }
  endsWithEnclosingMark(text) {
    return new RegExp(`${this.options.trigger}$`).test(text);
  }
  startsWithTriggeringMark(text) {
    return new RegExp(`^${this.options.trigger}`).test(text);
  }
  getText() {
    return this.text.replaceAll(/^:|:$/g, "");
  }
  getTextSize() {
    return this.text.length;
  }
  hasEnclosingTriggeringMark() {
    return this.endsWithEnclosingMark(this.text);
  }
  reset() {
    this.text = "";
    this.setIsTriggering(false);
    this._hasTriggeringMark = false;
    return this;
  }
  setIsTriggering(isTriggering) {
    this._isTriggering = isTriggering;
    return this;
  }
  setText(text) {
    this._hasTriggeringMark = this.startsWithTriggeringMark(text);
    this.setIsTriggering(
      this._hasTriggeringMark && text.length > this.options.limitTriggeringChars
    );
    this.text = this.isTriggering ? text : "";
    return this;
  }
  get hasTriggeringMark() {
    return this._hasTriggeringMark;
  }
  get isTriggering() {
    return this._isTriggering;
  }
};

// src/utils/EmojiLibrary/EmojiFloatingGrid.ts
var import_react = __toESM(require("react"));

// src/utils/Grid/Grid.ts
var Grid = class {
  constructor() {
    this.grid = /* @__PURE__ */ new Map();
    this.rowsCount = 1;
    this.sectionsIds = [];
  }
  addSection(sectionId, section, elements) {
    section.setIndexRowStart(this.rowsCount).addElements(elements[sectionId]);
    this.rowsCount += section.rowsNum;
    this.grid.set(sectionId, section);
    this.sectionsIds.push(sectionId);
    return this;
  }
  indexOf(sectionId) {
    return this.sectionsIds.indexOf(sectionId);
  }
  section(sectionId) {
    return this.grid.get(sectionId);
  }
  sections() {
    return Array.from(this.grid.values());
  }
  updateSection(sectionId, elements) {
    if (this.grid.has(sectionId)) {
      const section = this.grid.get(sectionId);
      section.updateElements(elements);
    }
    return this;
  }
  get size() {
    return this.grid.size;
  }
};

// src/utils/Grid/GridSection.ts
var AGridSection = class {
  constructor(_id, perLine = 8) {
    this._id = _id;
    this.perLine = perLine;
    this._indexRowStart = 0;
    this._rowsNum = 0;
    this.rows = [];
    this.createRootRef();
  }
  addRow(elements, lastPosition) {
    const start = lastPosition * this.perLine;
    const end = start + this.perLine;
    this.rows.push({
      elements: elements.slice(start, end),
      id: this._indexRowStart + lastPosition
    });
  }
  initRows(elements) {
    let i = 0;
    while (i < this.rowsNum) {
      this.addRow(elements, i++);
    }
  }
  addElements(elements) {
    this._rowsNum = Math.ceil(elements.length / this.perLine);
    this.initRows(elements);
    return this;
  }
  getRows() {
    return this.rows;
  }
  setIndexRowStart(start) {
    this._indexRowStart = start;
    return this;
  }
  updateElements(elements) {
    this.rows = [];
    this.addElements(elements);
    return this;
  }
  get id() {
    return this._id;
  }
  get root() {
    return this._root;
  }
  get rowsNum() {
    return this._rowsNum;
  }
};

// src/utils/EmojiLibrary/EmojiFloatingGrid.ts
var EmojiFloatingGrid = class extends Grid {
  createRootRef() {
    return import_react.default.createRef();
  }
};
var EmojiGridSectionWithRoot = class extends AGridSection {
  createRootRef() {
    this._root = import_react.default.createRef();
  }
};

// src/utils/EmojiLibrary/EmojiFloatingGridBuilder.ts
var EmojiFloatingGridBuilder = class {
  constructor(localStorage, sections, elements, settings) {
    this.localStorage = localStorage;
    this.sections = sections;
    this.elements = elements;
    this.settings = settings;
    this.grid = new EmojiFloatingGrid();
  }
  addFrequent() {
    if (this.settings.showFrequent.value) {
      const id = "frequent";
      this.grid.addSection(
        id,
        new EmojiGridSectionWithRoot(id, this.settings.perLine.value),
        {
          [id]: this.localStorage.getList()
        }
      );
    }
  }
  build() {
    this.addFrequent();
    this.sections.forEach((id) => {
      this.grid.addSection(
        id,
        new EmojiGridSectionWithRoot(id, this.settings.perLine.value),
        this.elements
      );
    });
    return this.grid;
  }
};

// src/utils/EmojiLibrary/EmojiFloatingLibrary.ts
var import_data2 = __toESM(require("@emoji-mart/data"));

// src/utils/EmojiLibrary/EmojiInlineLibrary.ts
var import_data = __toESM(require("@emoji-mart/data"));
var EmojiInlineLibrary = class {
  constructor(library = import_data.default) {
    this._hash = {};
    this._keys = [];
    this._emojis = library.emojis;
    this.init();
  }
  createSearchableString(emoji) {
    const { id, keywords, name } = emoji;
    return `${id},${this.getName(name)},${keywords.join(",")}`;
  }
  getName(name) {
    return name.toLowerCase().split(" ").join(",");
  }
  init() {
    Object.values(this._emojis).forEach((emoji) => {
      const searchableString = this.createSearchableString(emoji);
      this._keys.push(searchableString);
      this._hash[searchableString] = emoji.id;
    });
  }
  getEmoji(id) {
    return this._emojis[id];
  }
  getEmojiId(key) {
    return this._hash[key];
  }
  get keys() {
    return this._keys;
  }
};

// src/utils/EmojiLibrary/EmojiFloatingLibrary.ts
var EmojiFloatingLibrary = class _EmojiFloatingLibrary extends EmojiInlineLibrary {
  constructor(settings, localStorage, library = import_data2.default) {
    var _a;
    super(library);
    this.settings = settings;
    this.localStorage = localStorage;
    this.library = library;
    this.categories = defaultCategories;
    this.emojis = {};
    this.categories = (_a = settings.categories.value) != null ? _a : this.categories;
    this.initEmojis(library.categories);
    this.grid = new EmojiFloatingGridBuilder(
      this.localStorage,
      this.categories,
      this.emojis,
      settings
    ).build();
  }
  static getInstance(settings, localStorage, library = import_data2.default) {
    if (!_EmojiFloatingLibrary.instance) {
      _EmojiFloatingLibrary.instance = new _EmojiFloatingLibrary(
        settings,
        localStorage,
        library
      );
    }
    return _EmojiFloatingLibrary.instance;
  }
  initEmojis(categoriesLibrary) {
    for (const category of categoriesLibrary) {
      this.emojis[category.id] = category.emojis;
    }
  }
  getGrid() {
    return this.grid;
  }
  indexOf(focusedCategory) {
    const index = this.grid.indexOf(focusedCategory);
    return index < 1 ? 0 : index;
  }
  updateFrequentCategory(emojiId) {
    this.localStorage.update(emojiId);
    this.grid.updateSection(
      EmojiCategory.Frequent,
      this.localStorage.getList()
    );
  }
};

// src/utils/EmojiPicker/EmojiPickerState.ts
var import_react2 = __toESM(require("react"));
var initialState = {
  emoji: void 0,
  focusedCategory: void 0,
  frequentEmoji: void 0,
  hasFound: false,
  isOpen: false,
  isSearching: false,
  searchResult: [],
  searchValue: "",
  visibleCategories: /* @__PURE__ */ new Map()
};
var EmojiPickerState = () => {
  const [cache, dispatch] = import_react2.default.useReducer((state, action) => {
    const { payload, type } = action;
    switch (type) {
      case "CLEAR_SEARCH": {
        return __spreadProps(__spreadValues({}, state), {
          focusedCategory: EmojiCategory.Frequent,
          hasFound: false,
          isSearching: false,
          searchValue: ""
        });
      }
      case "UPDATE_SEARCH_RESULT": {
        return __spreadProps(__spreadValues(__spreadValues({}, state), payload), {
          focusedCategory: void 0,
          isSearching: true
        });
      }
      case "SET_FOCUSED_CATEGORY": {
        return __spreadProps(__spreadValues(__spreadValues({}, state), payload), {
          hasFound: false,
          isSearching: false,
          searchValue: ""
        });
      }
      case "SET_OPEN": {
        return __spreadProps(__spreadValues({}, state), {
          isOpen: true
        });
      }
      case "SET_CLOSE": {
        return __spreadProps(__spreadValues({}, state), {
          emoji: void 0,
          isOpen: false
        });
      }
      case "UPDATE_FREQUENT_EMOJIS": {
        return __spreadProps(__spreadValues(__spreadValues({}, state), payload), {
          emoji: void 0
        });
      }
      case "SET_SEARCH":
      case "SET_EMOJI":
      case "SET_FOCUSED_AND_VISIBLE_CATEGORIES": {
        return __spreadValues(__spreadValues({}, state), payload);
      }
      default: {
        throw new Error(`Unhandled action type: ${type}`);
      }
    }
  }, initialState);
  return [cache, dispatch];
};

// src/utils/EmojiPicker/useEmojiPicker.ts
var import_react3 = __toESM(require("react"));
var import_plate_common2 = require("@udecode/plate-common");

// src/handlers/getEmojiOnInsert.ts
var import_plate_common = require("@udecode/plate-common");
var import_server = require("@udecode/plate-common/server");
var getEmojiOnInsert = ({
  key = KEY_EMOJI
} = {}) => (editor, item) => {
  const {
    options: { createEmoji }
  } = (0, import_server.getPlugin)(editor, key);
  (0, import_server.withoutNormalizing)(editor, () => {
    (0, import_plate_common.focusEditor)(editor);
    const value = createEmoji(item);
    (0, import_server.insertText)(editor, value);
  });
};

// src/utils/EmojiObserver.ts
var setVisibleSections = (entries, visibleSections) => {
  for (const entry of entries) {
    const id = entry.target.dataset.id;
    visibleSections.set(id, entry.isIntersecting);
  }
};
var getSectionInFocus = (visibleSections) => {
  for (const [id, ratio] of visibleSections) {
    if (ratio) {
      return id;
    }
  }
};
var observeCategories = ({
  ancestorRef,
  emojiLibrary,
  setFocusedAndVisibleSections
}) => {
  const observerOptions = {
    root: ancestorRef.current,
    threshold: 0
  };
  const visibleSections = /* @__PURE__ */ new Map();
  const observer = new IntersectionObserver((entries) => {
    setVisibleSections(entries, visibleSections);
    const focusedSectionId = getSectionInFocus(visibleSections);
    focusedSectionId && setFocusedAndVisibleSections(visibleSections, focusedSectionId);
  }, observerOptions);
  for (const section of emojiLibrary.getGrid().sections()) {
    if (section.root.current)
      observer.observe(section.root.current);
  }
  return observer;
};

// src/utils/EmojiPicker/useEmojiPicker.ts
var useEmojiPicker = ({
  closeOnSelect,
  emojiLibrary,
  indexSearch
}) => {
  const editor = (0, import_plate_common2.useEditorRef)();
  const [state, dispatch] = EmojiPickerState();
  const refs = import_react3.default.useRef({
    content: import_react3.default.createRef(),
    contentRoot: import_react3.default.createRef()
  });
  const setIsOpen = import_react3.default.useCallback(
    (isOpen) => {
      dispatch({
        type: isOpen ? "SET_OPEN" : "SET_CLOSE"
      });
    },
    [dispatch]
  );
  const setFocusedAndVisibleSections = import_react3.default.useCallback(
    (visibleSections, categoryId) => {
      dispatch({
        payload: {
          focusedCategory: categoryId,
          visibleCategories: visibleSections
        },
        type: "SET_FOCUSED_AND_VISIBLE_CATEGORIES"
      });
    },
    [dispatch]
  );
  const handleSearchInput = import_react3.default.useCallback(
    (input) => {
      const value = String(input).replaceAll(/\s/g, "");
      if (!value && !input) {
        dispatch({ type: "CLEAR_SEARCH" });
        return;
      }
      const hasFound = indexSearch.search(value).hasFound();
      dispatch({
        payload: {
          hasFound,
          searchResult: indexSearch.get(),
          searchValue: value
        },
        type: "UPDATE_SEARCH_RESULT"
      });
    },
    [dispatch, indexSearch]
  );
  const setSearch = import_react3.default.useCallback(
    (value) => {
      value ? handleSearchInput(value) : dispatch({ type: "CLEAR_SEARCH" });
    },
    [dispatch, handleSearchInput]
  );
  const clearSearch = import_react3.default.useCallback(() => {
    dispatch({ type: "CLEAR_SEARCH" });
  }, [dispatch]);
  const onMouseOver = import_react3.default.useCallback(
    (emoji) => {
      dispatch({ payload: { emoji }, type: "SET_EMOJI" });
    },
    [dispatch]
  );
  const updateFrequentEmojis = import_react3.default.useCallback(
    (emojiId) => {
      emojiLibrary.updateFrequentCategory(emojiId);
      dispatch({
        payload: {
          frequentEmoji: emojiId,
          isOpen: closeOnSelect ? false : state.isOpen
        },
        type: "UPDATE_FREQUENT_EMOJIS"
      });
    },
    [closeOnSelect, dispatch, emojiLibrary, state.isOpen]
  );
  const onSelectEmoji = import_react3.default.useCallback(
    (emoji) => {
      const selectItem = getEmojiOnInsert();
      selectItem(editor, {
        data: {
          emoji: emoji.skins[0].native,
          id: emoji.id,
          name: emoji.name,
          text: emoji.name
        },
        key: emoji.id,
        text: emoji.name
      });
      updateFrequentEmojis(emoji.id);
    },
    [editor, updateFrequentEmojis]
  );
  const handleCategoryClick = import_react3.default.useCallback(
    (categoryId) => {
      dispatch({
        payload: { focusedCategory: categoryId },
        type: "SET_FOCUSED_CATEGORY"
      });
      const getSectionPositionToScrollIntoView = () => {
        var _a, _b, _c, _d, _e, _f;
        const trashHold = 1;
        const section = emojiLibrary.getGrid().section(categoryId);
        const contentRootScrollTop = (_b = (_a = refs.current.contentRoot.current) == null ? void 0 : _a.scrollTop) != null ? _b : 0;
        const contentRootTopPosition = (_d = (_c = refs.current.contentRoot.current) == null ? void 0 : _c.getBoundingClientRect().top) != null ? _d : 0;
        const sectionTopPosition = (_f = (_e = section == null ? void 0 : section.root.current) == null ? void 0 : _e.getBoundingClientRect().top) != null ? _f : 0;
        return trashHold + contentRootScrollTop + sectionTopPosition - contentRootTopPosition;
      };
      if (refs.current.contentRoot.current) {
        refs.current.contentRoot.current.scrollTop = getSectionPositionToScrollIntoView();
      }
    },
    [dispatch, emojiLibrary]
  );
  import_react3.default.useEffect(() => {
    if (state.isOpen && !state.isSearching) {
      setTimeout(() => {
        observeCategories({
          ancestorRef: refs.current.contentRoot,
          emojiLibrary,
          setFocusedAndVisibleSections
        });
      }, 0);
    }
  }, [
    emojiLibrary,
    state.isOpen,
    state.isSearching,
    setFocusedAndVisibleSections
  ]);
  return __spreadValues({
    clearSearch,
    emoji: state.emoji,
    emojiLibrary,
    handleCategoryClick,
    i18n,
    onMouseOver,
    onSelectEmoji,
    refs,
    setIsOpen,
    setSearch
  }, state);
};

// src/utils/IndexSearch/IndexSearch.ts
var AIndexSearch = class {
  constructor(library) {
    this.library = library;
    this.maxResult = EMOJI_MAX_SEARCH_RESULT;
    this.result = [];
    this.scores = {};
  }
  createSearchResult(value) {
    this.scores = {};
    this.result = [];
    for (const key of this.library.keys) {
      const score = key.indexOf(`${value}`);
      if (score === -1)
        continue;
      const emojiId = this.library.getEmojiId(key);
      this.result.push(emojiId);
      this.scores[emojiId] || (this.scores[emojiId] = 0);
      this.scores[emojiId] += emojiId === value ? 0 : score + 1;
    }
  }
  sortResultByScores(result, scores) {
    result.sort((a, b) => {
      const aScore = scores[a];
      const bScore = scores[b];
      if (aScore === bScore) {
        return a.localeCompare(b);
      }
      return aScore - bScore;
    });
  }
  get() {
    var _a;
    const emojis = [];
    for (const key of this.result) {
      const emoji = (_a = this.library) == null ? void 0 : _a.getEmoji(key);
      emojis.push(this.transform(emoji));
      if (emojis.length >= this.maxResult)
        break;
    }
    return emojis;
  }
  getEmoji() {
    return this.get()[0];
  }
  hasFound(exact = false) {
    if (exact && this.input) {
      return this.result.includes(this.input);
    }
    return this.result.length > 0;
  }
  search(input) {
    this.input = input.toLowerCase();
    const value = this.input;
    if (value) {
      this.createSearchResult(value);
      this.sortResultByScores(this.result, this.scores);
    } else {
      this.scores = {};
      this.result = [];
    }
    return this;
  }
};

// src/utils/IndexSearch/EmojiFloatingIndexSearch.ts
var EmojiFloatingIndexSearch = class _EmojiFloatingIndexSearch extends AIndexSearch {
  constructor(library) {
    super(library);
    this.library = library;
  }
  static getInstance(library) {
    if (!_EmojiFloatingIndexSearch.instance) {
      _EmojiFloatingIndexSearch.instance = new _EmojiFloatingIndexSearch(library);
    }
    return _EmojiFloatingIndexSearch.instance;
  }
  transform(emoji) {
    return emoji;
  }
};

// src/utils/IndexSearch/EmojiInlineIndexSearch.ts
var EmojiInlineIndexSearch = class _EmojiInlineIndexSearch extends AIndexSearch {
  constructor(library) {
    super(library);
    this.library = library;
  }
  static getInstance() {
    if (!_EmojiInlineIndexSearch.instance) {
      _EmojiInlineIndexSearch.instance = new _EmojiInlineIndexSearch(
        new EmojiInlineLibrary()
      );
    }
    return _EmojiInlineIndexSearch.instance;
  }
  transform(emoji) {
    const { id, name, skins } = emoji;
    return {
      data: {
        emoji: skins[0].native,
        id,
        name,
        text: name
      },
      key: id,
      text: name
    };
  }
};

// src/withEmoji.ts
var import_plate_combobox2 = require("@udecode/plate-combobox");
var import_server4 = require("@udecode/plate-common/server");

// src/handlers/getEmojiOnSelectItem.ts
var import_plate_combobox = require("@udecode/plate-combobox");
var import_server2 = require("@udecode/plate-common/server");
var getEmojiOnSelectItem = ({
  key = KEY_EMOJI
} = {}) => (editor, item) => {
  const {
    options: { createEmoji, emojiTriggeringController }
  } = (0, import_server2.getPlugin)(editor, key);
  (0, import_server2.withoutNormalizing)(editor, () => {
    (0, import_server2.withoutMergingHistory)(
      editor,
      () => (0, import_server2.deleteText)(editor, {
        distance: emojiTriggeringController.setIsTriggering(false).getTextSize(),
        reverse: true
      })
    );
    const value = createEmoji(item);
    (0, import_server2.insertText)(editor, value);
  });
  return import_plate_combobox.comboboxActions.reset();
};

// src/handlers/getFindTriggeringInput.ts
var import_server3 = require("@udecode/plate-common/server");
var isSpaceBreak = (char) => !!char && /\s/.test(char);
var getPreviousChar = (editor, point) => point ? (0, import_server3.getEditorString)(
  editor,
  (0, import_server3.getRange)(editor, point, (0, import_server3.getPointBefore)(editor, point))
) : void 0;
var getPreviousPoint = (editor, point) => point ? (0, import_server3.getPointBefore)(editor, point) : void 0;
var isBeginningOfTheLine = (editor, point) => {
  const previousPoint = getPreviousPoint(editor, point);
  return (point == null ? void 0 : point.path[0]) !== (previousPoint == null ? void 0 : previousPoint.path[0]);
};
var getFindTriggeringInput = (editor, emojiTriggeringController) => ({ action = "insert", char = "" } = {}) => {
  const { selection } = editor;
  if (!selection || !(0, import_server3.isCollapsed)(selection) || isSpaceBreak(char)) {
    emojiTriggeringController.setIsTriggering(false);
    return;
  }
  const startPoint = selection.anchor;
  let currentPoint = startPoint;
  let previousPoint;
  let foundText = char;
  let previousChar;
  do {
    previousChar = getPreviousChar(editor, currentPoint);
    foundText = previousChar + foundText;
    previousPoint = getPreviousPoint(editor, currentPoint);
    if (isBeginningOfTheLine(editor, currentPoint)) {
      break;
    }
    currentPoint = previousPoint;
  } while (!isSpaceBreak(previousChar));
  foundText = foundText.trim();
  if (action === "delete")
    foundText = foundText.slice(0, -1);
  emojiTriggeringController.setText(foundText);
};

// src/withEmoji.ts
var withEmoji = (editor, {
  options: { emojiTriggeringController, id }
}) => {
  const emojiInlineIndexSearch = EmojiInlineIndexSearch.getInstance();
  const findTheTriggeringInput = getFindTriggeringInput(
    editor,
    emojiTriggeringController
  );
  const { apply, deleteBackward, deleteForward, insertText: insertText3 } = editor;
  editor.insertText = (char) => {
    const { selection } = editor;
    if (!(0, import_server4.isCollapsed)(selection)) {
      return insertText3(char);
    }
    findTheTriggeringInput({ char });
    return insertText3(char);
  };
  editor.deleteBackward = (unit) => {
    findTheTriggeringInput({ action: "delete" });
    return deleteBackward(unit);
  };
  editor.deleteForward = (unit) => {
    findTheTriggeringInput();
    return deleteForward(unit);
  };
  editor.apply = (operation) => {
    apply(operation);
    if (!(emojiTriggeringController == null ? void 0 : emojiTriggeringController.hasTriggeringMark)) {
      return;
    }
    const searchText = emojiTriggeringController.getText();
    switch (operation.type) {
      case "set_selection": {
        emojiTriggeringController.reset();
        import_plate_combobox2.comboboxActions.reset();
        break;
      }
      case "insert_text": {
        if (emojiTriggeringController.hasEnclosingTriggeringMark() && emojiInlineIndexSearch.search(searchText).hasFound(true)) {
          const item = emojiInlineIndexSearch.getEmoji();
          item && getEmojiOnSelectItem()(editor, item);
          break;
        }
        if (!emojiTriggeringController.hasEnclosingTriggeringMark() && emojiTriggeringController.isTriggering && emojiInlineIndexSearch.search(searchText).hasFound()) {
          import_plate_combobox2.comboboxActions.items(
            emojiInlineIndexSearch.search(searchText).get()
          );
          import_plate_combobox2.comboboxActions.open({
            activeId: id,
            targetRange: editor.selection,
            text: ""
          });
          break;
        }
        emojiTriggeringController.reset();
        import_plate_combobox2.comboboxActions.reset();
        break;
      }
      case "remove_text": {
        if (emojiTriggeringController.isTriggering && emojiInlineIndexSearch.search(searchText).hasFound()) {
          import_plate_combobox2.comboboxActions.items(
            emojiInlineIndexSearch.search(searchText).get()
          );
          import_plate_combobox2.comboboxActions.open({
            activeId: id,
            targetRange: editor.selection,
            text: ""
          });
          break;
        }
        emojiTriggeringController.reset();
        import_plate_combobox2.comboboxActions.reset();
        break;
      }
    }
  };
  return editor;
};

// src/createEmojiPlugin.ts
var createEmojiPlugin = (0, import_server5.createPluginFactory)({
  key: KEY_EMOJI,
  options: {
    createEmoji: (item) => item.data.emoji,
    emojiTriggeringController: new EmojiTriggeringController(),
    trigger: EMOJI_TRIGGER
  },
  then: (_, { key, options: { createEmoji, emojiTriggeringController, trigger } }) => ({
    options: {
      createEmoji,
      emojiTriggeringController,
      id: key,
      trigger
    }
  }),
  withOverrides: withEmoji
});

// src/hooks/useEmojiCombobox.ts
var import_plate_common3 = require("@udecode/plate-common");
var import_server6 = require("@udecode/plate-common/server");
var useEmojiComboboxState = ({ pluginKey }) => {
  const editor = (0, import_plate_common3.useEditorRef)();
  const { trigger } = (0, import_server6.getPluginOptions)(editor, pluginKey);
  const onSelectItem = getEmojiOnSelectItem({ key: pluginKey });
  return {
    onSelectItem,
    trigger
  };
};

// src/hooks/useEmojiDropdownMenuState.ts
var import_plate_common4 = require("@udecode/plate-common");
function useEmojiDropdownMenuState({
  closeOnSelect = true,
  settings = EmojiSettings
} = {}) {
  const [emojiLibrary, indexSearch] = (0, import_plate_common4.useStableMemo)(() => {
    const frequentEmojiStorage = new FrequentEmojiStorage({
      limit: settings.showFrequent.limit
    });
    const emojiLibrary2 = EmojiFloatingLibrary.getInstance(
      settings,
      frequentEmojiStorage
    );
    const indexSearch2 = EmojiFloatingIndexSearch.getInstance(emojiLibrary2);
    return [emojiLibrary2, indexSearch2];
  }, [settings]);
  const _a = useEmojiPicker({
    closeOnSelect,
    emojiLibrary,
    indexSearch
  }), { isOpen, setIsOpen } = _a, emojiPickerState = __objRest(_a, ["isOpen", "setIsOpen"]);
  return {
    emojiPickerState,
    isOpen,
    setIsOpen
  };
}

// src/storage/LocalStorage.ts
var LocalStorage = class {
  constructor(key, defaultValue) {
    this.key = key;
    this.defaultValue = defaultValue;
  }
  get() {
    let value = this.defaultValue;
    if (typeof window === "undefined")
      return value;
    const valueInLocalStorage = window.localStorage.getItem(this.key);
    if (valueInLocalStorage) {
      try {
        value = JSON.parse(valueInLocalStorage);
      } catch (e) {
        window.localStorage.removeItem(this.key);
      }
    }
    return value;
  }
  set(value) {
    window.localStorage.setItem(this.key, JSON.stringify(value));
  }
};

// src/storage/FrequentEmojiStorage.ts
var FrequentEmojiStorage = class {
  constructor(props, defaultValue = DEFAULT_FREQUENTLY_USED_EMOJI) {
    this.defaultValue = defaultValue;
    this.key = EmojiCategory.Frequent;
    this.limit = 8;
    this.prefix = "emoji";
    var _a, _b, _c;
    this.limit = (_a = props.limit) != null ? _a : this.limit;
    const key = `${(_b = props.prefix) != null ? _b : this.prefix}:${(_c = props.key) != null ? _c : this.key}`;
    this.localStorage = new LocalStorage(key, defaultValue);
  }
  get() {
    const data = this.localStorage.get();
    return Object.fromEntries(
      Object.keys(data).sort((a, b) => data[b] - data[a]).map((key) => [key, data[key]])
    );
  }
  getList() {
    return Object.keys(this.get()).splice(0, this.limit);
  }
  set(value) {
    this.localStorage.set(value);
  }
  update(emojiId) {
    const prevEmojis = this.localStorage.get();
    const count = prevEmojis[emojiId] ? prevEmojis[emojiId] + 1 : 1;
    const emojis = __spreadProps(__spreadValues({}, prevEmojis), {
      [emojiId]: count
    });
    this.localStorage.set(emojis);
    return emojis;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AGridSection,
  AIndexSearch,
  DEFAULT_FREQUENTLY_USED_EMOJI,
  EMOJI_MAX_SEARCH_RESULT,
  EMOJI_TRIGGER,
  EmojiCategory,
  EmojiFloatingGrid,
  EmojiFloatingGridBuilder,
  EmojiFloatingIndexSearch,
  EmojiFloatingLibrary,
  EmojiGridSectionWithRoot,
  EmojiInlineIndexSearch,
  EmojiInlineLibrary,
  EmojiPickerState,
  EmojiSettings,
  EmojiTriggeringController,
  FrequentEmojiStorage,
  Grid,
  KEY_EMOJI,
  LocalStorage,
  NUM_OF_CATEGORIES,
  createEmojiPlugin,
  defaultCategories,
  emojiTriggeringControllerOptions,
  getEmojiOnInsert,
  getEmojiOnSelectItem,
  getFindTriggeringInput,
  i18n,
  useEmojiComboboxState,
  useEmojiDropdownMenuState,
  useEmojiPicker,
  withEmoji
});
//# sourceMappingURL=index.js.map