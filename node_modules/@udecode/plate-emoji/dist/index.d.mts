import { TComboboxItem, ComboboxOnSelectItem, Data, NoData, ComboboxProps } from '@udecode/plate-combobox';
import React from 'react';
import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { Value, PlateEditor, WithPlatePlugin, PlatePluginKey } from '@udecode/plate-common/server';
import * as _udecode_slate from '@udecode/slate';

type EmojiTriggeringControllerOptions = {
    limitTriggeringChars: number;
    trigger: string;
};
interface IEmojiTriggeringController {
    getText: () => string;
    getTextSize: () => number;
    hasEnclosingTriggeringMark: () => boolean;
    hasTriggeringMark: boolean;
    isTriggering: boolean;
    reset: () => this;
    setIsTriggering: (isTriggering: boolean) => this;
    setText: (text: string) => this;
}
declare class EmojiTriggeringController implements IEmojiTriggeringController {
    protected options: EmojiTriggeringControllerOptions;
    private _hasTriggeringMark;
    private _isTriggering;
    protected pos: any;
    protected text: string;
    constructor(options?: EmojiTriggeringControllerOptions);
    private endsWithEnclosingMark;
    private startsWithTriggeringMark;
    getText(): string;
    getTextSize(): number;
    hasEnclosingTriggeringMark(): boolean;
    reset(): this;
    setIsTriggering(isTriggering: boolean): this;
    setText(text: string): this;
    get hasTriggeringMark(): boolean;
    get isTriggering(): boolean;
}

type ReverseMap<T> = T[keyof T];
type EmojiSettingsType = {
    buttonSize: {
        value: number;
    };
    categories: {
        value?: EmojiCategoryList[];
    };
    perLine: {
        value: number;
    };
    showFrequent: {
        key?: string;
        limit?: number;
        prefix?: string;
        value: boolean;
    };
};
type EmojiItemData = {
    emoji: string;
    id: string;
    name: string;
    text: string;
};
type CreateEmoji<TData extends EmojiItemData = EmojiItemData> = (data: TComboboxItem<TData>) => string;
interface EmojiPlugin<TData extends EmojiItemData = EmojiItemData> {
    createEmoji?: CreateEmoji<TData>;
    emojiTriggeringController?: IEmojiTriggeringController;
    id?: string;
    trigger?: string;
}
declare const EmojiCategory: {
    readonly Activity: "activity";
    readonly Custom: "custom";
    readonly Flags: "flags";
    readonly Foods: "foods";
    readonly Frequent: "frequent";
    readonly Nature: "nature";
    readonly Objects: "objects";
    readonly People: "people";
    readonly Places: "places";
    readonly Symbols: "symbols";
};
type EmojiCategoryList = ReverseMap<typeof EmojiCategory>;
type i18nProps = {
    categories: Record<EmojiCategoryList, string>;
    clear: string;
    pick: string;
    search: string;
    searchNoResultsSubtitle: string;
    searchNoResultsTitle: string;
    searchResult: string;
    skins: Record<'1' | '2' | '3' | '4' | '5' | '6' | 'choose', string>;
};
type EmojiIconList<T = string> = {
    categories: Record<EmojiCategoryList, {
        outline: T;
        solid: T;
    }>;
    search: {
        delete: T;
        loupe: T;
    };
};
type FindTriggeringInputProps = {
    action?: 'delete' | 'insert';
    char?: string;
};

type Unknown = unknown;
type GridRow = {
    elements: string[];
    id: number;
};
type GridRows = GridRow[];
type SectionId = string;
type SectionElements = string[];
interface IGridSection<R, T> {
    addElements: (elements: SectionElements) => this;
    getRows: () => GridRows;
    id: T;
    root: R;
    rowsNum: number;
    setIndexRowStart: (start: number) => this;
    updateElements: (elements: SectionElements) => this;
}
type GridElements<S extends SectionId = SectionId> = Record<S, string[]>;
interface IGrid<R, T extends SectionId> {
    addSection: (sectionId: T, section: IGridSection<R, T>, elements: GridElements) => this;
    indexOf: (sectionId: T) => number;
    section: (sectionId: T) => IGridSection<R, T>;
    sections: () => IGridSection<R, T>[];
    size: number;
    updateSection: (sectionId: T, elements: SectionElements) => this;
}

declare class Grid<R, T extends SectionId = SectionId> implements IGrid<R, T> {
    protected grid: Map<T, IGridSection<R, T>>;
    protected rowsCount: number;
    protected sectionsIds: T[];
    addSection(sectionId: T, section: IGridSection<R, T>, elements: GridElements): this;
    indexOf(sectionId: T): number;
    section(sectionId: T): IGridSection<R, T>;
    sections(): IGridSection<R, T>[];
    updateSection(sectionId: T, elements: SectionElements): this;
    get size(): number;
}

declare abstract class AGridSection<R extends Unknown, T = SectionId> implements IGridSection<R, T> {
    protected _id: T;
    protected perLine: number;
    protected _indexRowStart: number;
    protected _root: R;
    protected _rowsNum: number;
    protected rows: GridRows;
    constructor(_id: T, perLine?: number);
    private addRow;
    private initRows;
    addElements(elements: SectionElements): this;
    getRows(): GridRows;
    setIndexRowStart(start: number): this;
    updateElements(elements: SectionElements): this;
    get id(): T;
    get root(): R;
    get rowsNum(): number;
    protected abstract createRootRef(): void;
}

type EmojiFloatingGridType = IGrid<React.RefObject<HTMLDivElement>, EmojiCategoryList>;
declare class EmojiFloatingGrid extends Grid<React.RefObject<HTMLDivElement>, EmojiCategoryList> {
    createRootRef(): React.RefObject<HTMLDivElement>;
}
declare class EmojiGridSectionWithRoot extends AGridSection<React.RefObject<HTMLDivElement>, EmojiCategoryList> {
    protected createRootRef(): void;
}

/**
 * Emoji: type Emoji = { id: string; name: string; keywords: string[]; skins: [
 * { unified: '1f389'; native: 'ðŸŽ‰'; shortcodes: ':tada:'; } ]; version: 1; };
 */
type Skin = {
    native: string;
    unified: string;
};
type Emoji = {
    id: string;
    keywords: string[];
    name: string;
    skins: Skin[];
    version: number;
};
type Emojis = Record<string, Emoji>;
type EmojiLibrary = {
    aliases: any;
    categories: any[];
    emojis: Emojis;
    sheet: any;
};
interface IEmojiLibrary {
    getEmoji: (key: string) => Emoji;
    getEmojiId: (key: string) => string;
    keys: string[];
}

type FrequentEmojis = Record<string, number>;
type FrequentEmojiStorageProps = {
    key?: string;
    limit?: number;
    prefix?: string;
};
interface IFrequentEmojiStorage {
    get: () => FrequentEmojis;
    getList: () => string[];
    set: (value: any) => void;
    update: (emojiId: string) => any;
}
interface IEmojiFloatingLibrary extends IEmojiLibrary {
    getGrid: () => EmojiFloatingGridType;
    indexOf: (focusedCategory: EmojiCategoryList) => number;
    updateFrequentCategory: (emojiId: string) => void;
}

declare class EmojiFloatingGridBuilder {
    protected localStorage: IFrequentEmojiStorage;
    protected sections: EmojiCategoryList[];
    protected elements: GridElements;
    protected settings: EmojiSettingsType;
    protected grid: EmojiFloatingGrid;
    constructor(localStorage: IFrequentEmojiStorage, sections: EmojiCategoryList[], elements: GridElements, settings: EmojiSettingsType);
    private addFrequent;
    build(): EmojiFloatingGrid;
}

type THash = Record<string, string>;
declare class EmojiInlineLibrary implements IEmojiLibrary {
    protected _emojis: Emojis;
    protected _hash: THash;
    protected _keys: string[];
    constructor(library?: EmojiLibrary);
    private createSearchableString;
    private getName;
    private init;
    getEmoji(id: string): Emoji;
    getEmojiId(key: string): string;
    get keys(): string[];
}

declare class EmojiFloatingLibrary extends EmojiInlineLibrary implements IEmojiFloatingLibrary {
    protected settings: EmojiSettingsType;
    protected localStorage: IFrequentEmojiStorage;
    protected library: EmojiLibrary;
    private categories;
    private emojis;
    private grid;
    private static instance?;
    private constructor();
    static getInstance(settings: EmojiSettingsType, localStorage: IFrequentEmojiStorage, library?: EmojiLibrary): EmojiFloatingLibrary;
    private initEmojis;
    getGrid(): EmojiFloatingGridType;
    indexOf(focusedCategory: EmojiCategoryList): number;
    updateFrequentCategory(emojiId: string): void;
}

type MapEmojiCategoryList = Map<EmojiCategoryList, boolean>;
type EmojiPickerStateProps = {
    emoji?: Emoji;
    focusedCategory?: EmojiCategoryList;
    frequentEmoji?: string;
    hasFound: boolean;
    isOpen: boolean;
    isSearching: boolean;
    searchResult: Emoji[];
    searchValue: string;
    visibleCategories: MapEmojiCategoryList;
};
type EmojiPickerStateDispatch = {
    payload?: Partial<EmojiPickerStateProps>;
    type: string;
};
declare const EmojiPickerState: () => [
    EmojiPickerStateProps,
    React.Dispatch<EmojiPickerStateDispatch>
];

type IndexSearchReturnData = TComboboxItem<EmojiItemData>;
interface IIndexSearch<R> {
    get: () => R[];
    hasFound: () => boolean;
    search: (input: string) => void;
}
declare abstract class AIndexSearch<RData = IndexSearchReturnData> implements IIndexSearch<RData> {
    protected library: IEmojiLibrary;
    protected input: string | undefined;
    protected maxResult: number;
    protected result: string[];
    protected scores: {};
    protected constructor(library: IEmojiLibrary);
    private createSearchResult;
    private sortResultByScores;
    get(): RData[];
    getEmoji(): RData | undefined;
    hasFound(exact?: boolean): boolean;
    search(input: string): this;
    protected abstract transform(emoji: Emoji): RData;
}

declare class EmojiFloatingIndexSearch extends AIndexSearch<Emoji> {
    protected library: IEmojiLibrary;
    protected static instance?: EmojiFloatingIndexSearch;
    private constructor();
    static getInstance(library: IEmojiLibrary): EmojiFloatingIndexSearch;
    protected transform(emoji: Emoji): Emoji;
}

declare class EmojiInlineIndexSearch extends AIndexSearch {
    protected library: IEmojiLibrary;
    protected static instance?: EmojiInlineIndexSearch;
    private constructor();
    static getInstance(): EmojiInlineIndexSearch;
    protected transform(emoji: Emoji): {
        data: {
            emoji: string;
            id: string;
            name: string;
            text: string;
        };
        key: string;
        text: string;
    };
}

type MutableRefs = React.MutableRefObject<{
    content: React.RefObject<HTMLDivElement> | undefined;
    contentRoot: React.RefObject<HTMLDivElement> | undefined;
}>;
type UseEmojiPickerProps = {
    closeOnSelect: boolean;
    emojiLibrary: IEmojiFloatingLibrary;
    indexSearch: AIndexSearch<Emoji>;
};
type UseEmojiPickerType<T extends React.ReactElement = React.ReactElement> = {
    clearSearch: () => void;
    emoji?: Emoji;
    emojiLibrary: IEmojiFloatingLibrary;
    focusedCategory?: EmojiCategoryList;
    handleCategoryClick: (id: EmojiCategoryList) => void;
    hasFound: boolean;
    i18n: i18nProps;
    icons: EmojiIconList<T>;
    isOpen: boolean;
    isSearching: boolean;
    onMouseOver: (emoji?: Emoji) => void;
    onSelectEmoji: (emoji: Emoji) => void;
    refs: MutableRefs;
    searchResult: Emoji[];
    searchValue: string;
    setIsOpen: (isOpen: boolean) => void;
    setSearch: (value: string) => void;
    settings?: EmojiSettingsType;
    styles?: any;
    visibleCategories: MapEmojiCategoryList;
};
declare const useEmojiPicker: ({ closeOnSelect, emojiLibrary, indexSearch, }: UseEmojiPickerProps) => Omit<UseEmojiPickerType, 'icons' | 'settings'>;

declare const KEY_EMOJI = "emoji";
declare const EMOJI_TRIGGER = ":";
declare const EMOJI_MAX_SEARCH_RESULT = 60;
declare const emojiTriggeringControllerOptions: EmojiTriggeringControllerOptions;
declare const defaultCategories: EmojiCategoryList[];
declare const EmojiSettings: EmojiSettingsType;
declare const DEFAULT_FREQUENTLY_USED_EMOJI: FrequentEmojis;
declare const NUM_OF_CATEGORIES: number;
declare const i18n: i18nProps;

declare const createEmojiPlugin: <OP = EmojiPlugin<EmojiItemData>, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const withEmoji: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { options: { emojiTriggeringController, id }, }: WithPlatePlugin<EmojiPlugin, V, E>) => E;

declare const getEmojiOnInsert: <TData extends EmojiItemData = EmojiItemData>({ key, }?: PlatePluginKey) => ComboboxOnSelectItem<TData>;

declare const getEmojiOnSelectItem: <TData extends EmojiItemData = EmojiItemData>({ key, }?: PlatePluginKey) => ComboboxOnSelectItem<TData>;

declare const getFindTriggeringInput: <V extends Value>(editor: PlateEditor<V>, emojiTriggeringController: IEmojiTriggeringController) => ({ action, char }?: FindTriggeringInputProps) => void;

interface TEmojiCombobox<TData extends Data = NoData> extends Partial<ComboboxProps<TData>> {
    onSelectItem?: ComboboxOnSelectItem<TData> | null;
    pluginKey?: string;
}
declare const useEmojiComboboxState: ({ pluginKey }: {
    pluginKey: string;
}) => {
    onSelectItem: ComboboxOnSelectItem<EmojiItemData>;
    trigger: string;
};

type EmojiDropdownMenuOptions = {
    closeOnSelect?: boolean;
    settings?: EmojiSettingsType;
};
declare function useEmojiDropdownMenuState({ closeOnSelect, settings, }?: EmojiDropdownMenuOptions): {
    emojiPickerState: {
        emoji?: Emoji | undefined;
        focusedCategory?: EmojiCategoryList | undefined;
        hasFound: boolean;
        isSearching: boolean;
        searchResult: Emoji[];
        searchValue: string;
        visibleCategories: MapEmojiCategoryList;
        emojiLibrary: IEmojiFloatingLibrary;
        clearSearch: () => void;
        handleCategoryClick: (id: EmojiCategoryList) => void;
        i18n: i18nProps;
        onMouseOver: (emoji?: Emoji | undefined) => void;
        onSelectEmoji: (emoji: Emoji) => void;
        refs: MutableRefs;
        setSearch: (value: string) => void;
        styles?: any;
    };
    isOpen: boolean;
    setIsOpen: (isOpen: boolean) => void;
};

interface ILocalStorage<T> {
    get: () => T;
    set: (value: T) => void;
}
declare class LocalStorage<T> implements ILocalStorage<T> {
    protected key: string;
    protected defaultValue: T;
    constructor(key: string, defaultValue: T);
    get(): T;
    set(value: any): void;
}

declare class FrequentEmojiStorage implements IFrequentEmojiStorage {
    protected defaultValue: FrequentEmojis;
    protected key: "frequent";
    protected limit: number;
    protected localStorage: LocalStorage<FrequentEmojis>;
    protected prefix: string;
    constructor(props: FrequentEmojiStorageProps, defaultValue?: FrequentEmojis);
    get(): FrequentEmojis;
    getList(): string[];
    set(value: any): void;
    update(emojiId: string): FrequentEmojis;
}

export { AGridSection, AIndexSearch, type CreateEmoji, DEFAULT_FREQUENTLY_USED_EMOJI, EMOJI_MAX_SEARCH_RESULT, EMOJI_TRIGGER, type Emoji, EmojiCategory, type EmojiCategoryList, type EmojiDropdownMenuOptions, EmojiFloatingGrid, EmojiFloatingGridBuilder, type EmojiFloatingGridType, EmojiFloatingIndexSearch, EmojiFloatingLibrary, EmojiGridSectionWithRoot, type EmojiIconList, EmojiInlineIndexSearch, EmojiInlineLibrary, type EmojiItemData, type EmojiLibrary, EmojiPickerState, type EmojiPickerStateDispatch, type EmojiPickerStateProps, type EmojiPlugin, EmojiSettings, type EmojiSettingsType, EmojiTriggeringController, type EmojiTriggeringControllerOptions, type Emojis, type FindTriggeringInputProps, FrequentEmojiStorage, type FrequentEmojiStorageProps, type FrequentEmojis, Grid, type GridElements, type GridRow, type GridRows, type IEmojiFloatingLibrary, type IEmojiLibrary, type IEmojiTriggeringController, type IFrequentEmojiStorage, type IGrid, type IGridSection, type ILocalStorage, KEY_EMOJI, LocalStorage, type MapEmojiCategoryList, type MutableRefs, NUM_OF_CATEGORIES, type SectionElements, type SectionId, type TEmojiCombobox, type THash, type Unknown, type UseEmojiPickerProps, type UseEmojiPickerType, createEmojiPlugin, defaultCategories, emojiTriggeringControllerOptions, getEmojiOnInsert, getEmojiOnSelectItem, getFindTriggeringInput, i18n, type i18nProps, useEmojiComboboxState, useEmojiDropdownMenuState, useEmojiPicker, withEmoji };
