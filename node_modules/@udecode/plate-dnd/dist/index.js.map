{"version":3,"sources":["../src/index.ts","../src/createDndPlugin.tsx","../src/components/Scroller/DndScroller.tsx","../src/dndStore.ts","../src/components/Scroller/Scroller.tsx","../src/components/Scroller/ScrollArea.tsx","../src/components/useDraggable.ts","../src/components/useWithDraggable.ts","../src/components/withDraggable.tsx","../src/hooks/useDndNode.ts","../src/hooks/useDragNode.ts","../src/hooks/useDropNode.ts","../src/transforms/onDropNode.ts","../src/utils/getHoverDirection.ts","../src/utils/getNewDirection.ts","../src/transforms/onHoverNode.ts","../src/hooks/useDragBlock.ts","../src/hooks/useDndBlock.ts","../src/hooks/useDropBlock.ts","../src/queries/getBlocksWithId.ts","../src/queries/getNodesRange.ts","../src/transforms/focusBlockStartById.ts","../src/transforms/removeBlocksAndFocus.ts","../src/transforms/selectBlockById.ts","../src/transforms/selectBlocksBySelectionOrId.ts"],"sourcesContent":["/** @file Automatically generated by barrelsby. */\n\nexport * from './createDndPlugin';\nexport * from './dndStore';\nexport * from './types';\nexport * from './components/index';\nexport * from './hooks/index';\nexport * from './queries/index';\nexport * from './transforms/index';\nexport * from './utils/index';\n","import React from 'react';\n\nimport { createPluginFactory } from '@udecode/plate-common/server';\n\nimport { DndScroller, type ScrollerProps } from './components/Scroller';\nimport { dndStore } from './dndStore';\n\nexport interface DndPlugin {\n  enableScroller?: boolean;\n  scrollerProps?: Partial<ScrollerProps>;\n}\n\nexport const KEY_DND = 'dnd';\n\nexport const createDndPlugin = createPluginFactory<DndPlugin>({\n  handlers: {\n    onDragEnd: () => () => dndStore.set.isDragging(false),\n    onDragStart: () => () => dndStore.set.isDragging(true),\n    onDrop: (editor) => () => editor.isDragging as boolean,\n  },\n  key: KEY_DND,\n  then: (editor, { options }) => ({\n    renderAfterEditable: options.enableScroller\n      ? () => <DndScroller {...options?.scrollerProps} />\n      : undefined,\n  }),\n});\n","import React from 'react';\n\nimport { dndStore } from '../../dndStore';\nimport { Scroller, type ScrollerProps } from './Scroller';\n\nexport function DndScroller(props: Partial<ScrollerProps>) {\n  const isDragging = dndStore.use.isDragging();\n  const [show, setShow] = React.useState(false);\n\n  React.useEffect(() => {\n    if (isDragging) {\n      const timeout = setTimeout(() => {\n        setShow(true);\n      }, 100);\n\n      return () => clearTimeout(timeout);\n    }\n\n    setShow(false);\n  }, [isDragging, show]);\n\n  return <Scroller enabled={isDragging && show} {...props} />;\n}\n","import { createZustandStore } from '@udecode/plate-common/server';\n\nexport const dndStore = createZustandStore('dnd')({\n  isDragging: false,\n});\n","import React from 'react';\n\nimport { ScrollArea, type ScrollAreaProps } from './ScrollArea';\n\nexport type ScrollerProps = Omit<ScrollAreaProps, 'placement'>;\n\n/**\n * Set up an edge scroller at the top of the page for scrolling up. One at the\n * bottom for scrolling down.\n */\nexport function Scroller(props: ScrollerProps) {\n  return (\n    <>\n      <ScrollArea placement=\"top\" {...props} />\n      <ScrollArea placement=\"bottom\" {...props} />\n    </>\n  );\n}\n","import React from 'react';\n\nimport throttle from 'lodash/throttle.js';\nimport raf from 'raf';\n\nconst getCoords = (e: any) => {\n  if (e.type === 'touchmove') {\n    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };\n  }\n\n  return { x: e.clientX, y: e.clientY };\n};\n\nexport interface ScrollAreaProps {\n  placement: 'bottom' | 'top';\n  containerRef?: React.RefObject<any>;\n  enabled?: boolean;\n  height?: number;\n  minStrength?: number;\n  scrollAreaProps?: React.HTMLAttributes<HTMLDivElement>;\n  strengthMultiplier?: number;\n  zIndex?: number;\n}\n\nexport function ScrollArea({\n  containerRef,\n  enabled = true,\n  height = 100,\n  minStrength = 0.15,\n  placement,\n  scrollAreaProps,\n  strengthMultiplier = 25,\n  zIndex = 10_000,\n}: ScrollAreaProps) {\n  const ref = React.useRef<HTMLDivElement>();\n\n  const scaleYRef = React.useRef(0);\n  const frameRef = React.useRef<null | number>(null);\n\n  const direction = placement === 'top' ? -1 : 1;\n\n  // Drag a fixed, invisible box of custom height at the top, and bottom\n  // of the window. Make sure to show it only when dragging something.\n  const style: React.CSSProperties = {\n    height,\n    opacity: 0,\n    position: 'fixed',\n    width: '100%',\n    zIndex,\n    ...scrollAreaProps?.style,\n  };\n\n  if (placement === 'top') {\n    style.top = 0;\n  } else if (placement === 'bottom') {\n    style.bottom = 0;\n  }\n\n  const stopScrolling = () => {\n    scaleYRef.current = 0;\n\n    if (frameRef.current) {\n      raf.cancel(frameRef.current);\n      frameRef.current = null;\n    }\n  };\n\n  const startScrolling = () => {\n    const tick = () => {\n      const scaleY = scaleYRef.current;\n\n      // stop scrolling if there's nothing to do\n      if (strengthMultiplier === 0 || scaleY === 0) {\n        stopScrolling();\n\n        return;\n      }\n\n      const container = containerRef?.current ?? window;\n      container.scrollBy(0, scaleY * strengthMultiplier * direction);\n\n      frameRef.current = raf(tick);\n\n      // there's a bug in safari where it seems like we can't get\n      // mousemove events from a container that also emits a scroll\n      // event that same frame. So we should double the strengthMultiplier and only adjust\n      // the scroll position at 30fps\n    };\n\n    tick();\n  };\n\n  // Update scaleY every 100ms or so\n  // and start scrolling if necessary\n  const updateScrolling = throttle(\n    (e) => {\n      const container = ref.current;\n\n      if (!container) return;\n\n      const { height: h, top: y } = container.getBoundingClientRect();\n      const coords = getCoords(e);\n\n      const strength = Math.max(Math.max(coords.y - y, 0) / h, minStrength);\n\n      // calculate strength\n      scaleYRef.current = direction === -1 ? 1 - strength : strength;\n\n      // start scrolling if we need to\n      if (!frameRef.current && scaleYRef.current) {\n        startScrolling();\n      }\n    },\n    100,\n    { trailing: false }\n  );\n\n  const handleEvent = (e: any) => {\n    updateScrolling(e);\n  };\n\n  React.useEffect(() => {\n    if (!enabled) {\n      stopScrolling();\n    }\n  }, [enabled]);\n\n  if (!enabled) return null;\n\n  // Hide the element if not enabled, so it doesn't interfere with clicking things under it.\n  return (\n    <div\n      onDragEnd={stopScrolling}\n      onDragLeave={stopScrolling}\n      onDragOver={handleEvent}\n      // would have to attach the listeners to the body\n      onTouchMove={handleEvent}\n      ref={ref as any}\n      // touchmove events don't seem to work across siblings, so we unfortunately\n      style={style}\n      {...scrollAreaProps}\n    />\n  );\n}\n","import React from 'react';\n\nimport type { TEditor, TElement } from '@udecode/plate-common/server';\nimport type { DropTargetMonitor } from 'react-dnd';\n\nimport { type DragItemNode, type DropLineDirection, useDndBlock } from '..';\n\nexport type DraggableState = {\n  dragRef: (\n    elementOrNode: Element | React.ReactElement | React.RefObject<any> | null\n  ) => void;\n  dropLine: DropLineDirection;\n  isDragging: boolean;\n  isHovered: boolean;\n  nodeRef: React.RefObject<HTMLDivElement>;\n  setIsHovered: (isHovered: boolean) => void;\n};\n\nexport const useDraggableState = (props: {\n  element: TElement;\n  onDropHandler?: (\n    editor: TEditor,\n    props: {\n      dragItem: DragItemNode;\n      id: string;\n      monitor: DropTargetMonitor<DragItemNode, unknown>;\n      nodeRef: any;\n    }\n  ) => boolean;\n}): DraggableState => {\n  const { element, onDropHandler } = props;\n\n  const nodeRef = React.useRef<HTMLDivElement>(null);\n  const [isHovered, setIsHovered] = React.useState(false);\n  const { dragRef, dropLine, isDragging } = useDndBlock({\n    id: element.id as string,\n    nodeRef,\n    onDropHandler,\n  });\n\n  return {\n    dragRef,\n    dropLine,\n    isDragging,\n    isHovered,\n    nodeRef,\n    setIsHovered,\n  };\n};\n\nexport const useDraggable = (state: DraggableState) => {\n  return {\n    droplineProps: {\n      contentEditable: false,\n    },\n    groupProps: {\n      onPointerEnter: () => state.setIsHovered(true),\n      onPointerLeave: () => state.setIsHovered(false),\n    },\n    gutterLeftProps: {\n      contentEditable: false,\n    },\n    handleRef: state.dragRef,\n    previewRef: state.nodeRef,\n  };\n};\n","import React from 'react';\n\nimport type {\n  PlateRenderElementProps,\n  TEditor,\n} from '@udecode/plate-common/server';\nimport type { Path } from 'slate';\n\nimport { findNodePath } from '@udecode/plate-common';\nimport { useReadOnly } from 'slate-react';\n\nexport interface WithDraggableOptions<T = any> {\n  /** Enables dnd in read-only. */\n  allowReadOnly?: boolean;\n\n  draggableProps?: T;\n\n  /** Filter out elements that can't be dragged. */\n  filter?: (editor: TEditor, path: Path) => boolean;\n  /**\n   * Document level where dnd is enabled. 0 = root blocks, 1 = first level of\n   * children, etc. Set to null to allow all levels.\n   *\n   * @default 0\n   */\n  level?: null | number;\n}\n\nexport const useWithDraggable = <T = any>({\n  allowReadOnly = false,\n  draggableProps,\n  editor,\n  element,\n  filter,\n  level = 0,\n}: PlateRenderElementProps & WithDraggableOptions<T>) => {\n  const readOnly = useReadOnly();\n  const path = React.useMemo(\n    () => findNodePath(editor, element),\n    [editor, element]\n  );\n\n  const filteredOut = React.useMemo(\n    () =>\n      path &&\n      ((Number.isInteger(level) && level !== path.length - 1) ||\n        filter?.(editor, path)),\n    [path, level, filter, editor]\n  );\n\n  return {\n    disabled: filteredOut || (!allowReadOnly && readOnly),\n    draggableProps: {\n      editor,\n      element,\n      ...draggableProps,\n    },\n  };\n};\n","import React from 'react';\n\nimport type {\n  AnyObject,\n  PlateRenderElementProps,\n} from '@udecode/plate-common/server';\n\nimport {\n  type WithDraggableOptions,\n  useWithDraggable,\n} from './useWithDraggable';\n\nexport const withDraggable = <T extends AnyObject = AnyObject>(\n  Draggable: React.FC<any>,\n  Component: React.FC<any>,\n  options?: WithDraggableOptions<T>\n) =>\n  // eslint-disable-next-line react/display-name\n  React.forwardRef<HTMLDivElement, PlateRenderElementProps>((props, ref) => {\n    const { disabled, draggableProps } = useWithDraggable({\n      ...options,\n      ...props,\n    });\n\n    if (disabled) {\n      return <Component {...props} />;\n    }\n\n    return (\n      <Draggable ref={ref} {...draggableProps}>\n        <Component {...props} />\n      </Draggable>\n    );\n  });\n","import React from 'react';\nimport { getEmptyImage } from 'react-dnd-html5-backend';\n\nimport type { TEditor } from '@udecode/plate-common/server';\nimport type { DropTargetMonitor } from 'react-dnd';\n\nimport { useEditorRef } from '@udecode/plate-common';\n\nimport type { DragItemNode, DropLineDirection } from '../types';\n\nimport { type UseDragNodeOptions, useDragNode } from './useDragNode';\nimport { type UseDropNodeOptions, useDropNode } from './useDropNode';\n\nexport interface UseDndNodeOptions\n  extends Pick<UseDropNodeOptions, 'id' | 'nodeRef'>,\n    Pick<UseDragNodeOptions, 'type'> {\n  drag?: UseDragNodeOptions;\n  drop?: UseDropNodeOptions;\n  onDropHandler?: (\n    editor: TEditor,\n    props: {\n      dragItem: DragItemNode;\n      id: string;\n      monitor: DropTargetMonitor<DragItemNode, unknown>;\n      nodeRef: any;\n    }\n  ) => boolean;\n  preview?: {\n    /** Whether to disable the preview. */\n    disable?: boolean;\n\n    /** The reference to the preview element. */\n    ref?: any;\n  };\n}\n\n/**\n * {@link useDragNode} and {@link useDropNode} hooks to drag and drop a node from\n * the editor. A default preview is used to show the node being dragged, which\n * can be customized or removed. Returns the drag ref and drop line direction.\n */\nexport const useDndNode = ({\n  drag: dragOptions,\n  drop: dropOptions,\n  id,\n  nodeRef,\n  onDropHandler,\n  preview: previewOptions = {},\n  type,\n}: UseDndNodeOptions) => {\n  const editor = useEditorRef();\n\n  const [dropLine, setDropLine] = React.useState<DropLineDirection>('');\n\n  const [{ isDragging }, dragRef, preview] = useDragNode(editor, {\n    id,\n    type,\n    ...dragOptions,\n  });\n  const [{ isOver }, drop] = useDropNode(editor, {\n    accept: type,\n    dropLine,\n    id,\n    nodeRef,\n    onChangeDropLine: setDropLine,\n    onDropHandler,\n    ...dropOptions,\n  });\n\n  if (previewOptions.disable) {\n    drop(nodeRef);\n    preview(getEmptyImage(), { captureDraggingState: true });\n  } else if (previewOptions.ref) {\n    drop(nodeRef);\n    preview(previewOptions.ref);\n  } else {\n    preview(drop(nodeRef));\n  }\n  if (!isOver && dropLine) {\n    setDropLine('');\n  }\n\n  return {\n    dragRef,\n    dropLine,\n    isDragging,\n    isOver,\n  };\n};\n","import { type DragSourceHookSpec, useDrag } from 'react-dnd';\n\nimport type { TEditor, Value } from '@udecode/plate-common/server';\n\nimport type { DragItemNode } from '../types';\n\nimport { dndStore } from '../dndStore';\n\nexport interface UseDragNodeOptions\n  extends DragSourceHookSpec<DragItemNode, unknown, { isDragging: boolean }> {\n  id: string;\n}\n\n/**\n * `useDrag` hook to drag a node from the editor. `item` with `id` is required.\n *\n * On drag start:\n *\n * - Set `editor.isDragging` to true\n * - Add `dragging` class to `body`\n *\n * On drag end:\n *\n * - Set `editor.isDragging` to false\n * - Remove `dragging` class to `body`\n *\n * Collect:\n *\n * - IsDragging: true if mouse is dragging the block\n */\nexport const useDragNode = <V extends Value>(\n  editor: TEditor<V>,\n  { id, item, ...options }: UseDragNodeOptions\n) => {\n  return useDrag<DragItemNode, unknown, { isDragging: boolean }>(\n    () => ({\n      collect: (monitor) => ({\n        isDragging: monitor.isDragging(),\n      }),\n      end: () => {\n        dndStore.set.isDragging(false);\n        editor.isDragging = false;\n        document.body.classList.remove('dragging');\n      },\n      item(monitor) {\n        dndStore.set.isDragging(true);\n        editor.isDragging = true;\n        document.body.classList.add('dragging');\n\n        const _item = typeof item === 'function' ? item(monitor) : item;\n\n        return {\n          editorId: editor.id,\n          id,\n          ..._item,\n        };\n      },\n      ...options,\n    }),\n    []\n  );\n};\n","import {\n  type DropTargetHookSpec,\n  type DropTargetMonitor,\n  useDrop,\n} from 'react-dnd';\n\nimport type { TReactEditor } from '@udecode/plate-common';\nimport type { TEditor, Value } from '@udecode/plate-common/server';\n\nimport type { DragItemNode, DropLineDirection } from '../types';\n\nimport { onDropNode } from '../transforms/onDropNode';\nimport { onHoverNode } from '../transforms/onHoverNode';\n\nexport interface UseDropNodeOptions\n  extends DropTargetHookSpec<DragItemNode, unknown, { isOver: boolean }> {\n  /** Current value of dropLine. */\n  dropLine: string;\n\n  /** Id of the node. */\n  id: string;\n\n  /** The reference to the node being dragged. */\n  nodeRef: any;\n\n  /** Callback called on dropLine change. */\n  onChangeDropLine: (newValue: DropLineDirection) => void;\n  /**\n   * Intercepts the drop handling. If `false` is returned, the default drop\n   * behavior is called after. If `true` is returned, the default behavior is\n   * not called.\n   */\n  onDropHandler?: (\n    editor: TEditor,\n    props: {\n      dragItem: DragItemNode;\n      id: string;\n      monitor: DropTargetMonitor<DragItemNode, unknown>;\n      nodeRef: any;\n    }\n  ) => boolean;\n}\n\n/**\n * `useDrop` hook to drop a node on the editor.\n *\n * On drop:\n *\n * - Get hover direction (top, bottom or undefined), return early if undefined\n * - DragPath: find node with id = dragItem.id, return early if not found\n * - Focus editor\n * - DropPath: find node with id = id, its path should be next (bottom) or\n *   previous (top)\n * - Move node from dragPath to dropPath\n *\n * On hover:\n *\n * - Get drop line direction\n * - If differs from dropLine, setDropLine is called\n *\n * Collect:\n *\n * - IsOver: true if mouse is over the block\n */\nexport const useDropNode = <V extends Value>(\n  editor: TReactEditor<V>,\n  {\n    dropLine,\n    id,\n    nodeRef,\n    onChangeDropLine,\n    onDropHandler,\n    ...options\n  }: UseDropNodeOptions\n) => {\n  return useDrop<DragItemNode, unknown, { isOver: boolean }>({\n    collect: (monitor) => ({\n      isOver: monitor.isOver(),\n    }),\n    drop: (dragItem, monitor) => {\n      const handled =\n        !!onDropHandler &&\n        onDropHandler(editor, {\n          dragItem,\n          id,\n          monitor,\n          nodeRef,\n        });\n\n      if (handled) return;\n\n      onDropNode(editor, { dragItem, id, monitor, nodeRef });\n    },\n    hover(item: DragItemNode, monitor: DropTargetMonitor) {\n      onHoverNode(editor, {\n        dragItem: item,\n        dropLine,\n        id,\n        monitor,\n        nodeRef,\n        onChangeDropLine,\n      });\n    },\n    ...options,\n  });\n};\n","import type { DropTargetMonitor } from 'react-dnd';\n\nimport { type TReactEditor, focusEditor } from '@udecode/plate-common';\nimport { type Value, findNode, moveNodes } from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport type { UseDropNodeOptions } from '../hooks';\nimport type { DragItemNode } from '../types';\n\nimport { getHoverDirection } from '../utils';\n\n/** Callback called on drag an drop a node with id. */\nexport const onDropNode = <V extends Value>(\n  editor: TReactEditor<V>,\n  {\n    dragItem,\n    id,\n    monitor,\n    nodeRef,\n  }: {\n    dragItem: DragItemNode;\n    monitor: DropTargetMonitor;\n  } & Pick<UseDropNodeOptions, 'id' | 'nodeRef'>\n) => {\n  const direction = getHoverDirection({ dragItem, id, monitor, nodeRef });\n\n  if (!direction) return;\n\n  const dragEntry = findNode(editor, {\n    at: [],\n    match: { id: dragItem.id },\n  });\n\n  if (!dragEntry) return;\n\n  const [, dragPath] = dragEntry;\n\n  focusEditor(editor);\n\n  let dropPath: Path | undefined;\n\n  if (direction === 'bottom') {\n    dropPath = findNode(editor, { at: [], match: { id } })?.[1];\n\n    if (!dropPath) return;\n    if (Path.equals(dragPath, Path.next(dropPath))) return;\n  }\n  if (direction === 'top') {\n    const nodePath = findNode(editor, { at: [], match: { id } })?.[1];\n\n    if (!nodePath) return;\n\n    dropPath = [...nodePath.slice(0, -1), nodePath.at(-1)! - 1];\n\n    if (Path.equals(dragPath, dropPath)) return;\n  }\n  if (direction) {\n    const _dropPath = dropPath as Path;\n\n    const before =\n      Path.isBefore(dragPath, _dropPath) && Path.isSibling(dragPath, _dropPath);\n    const to = before ? _dropPath : Path.next(_dropPath);\n\n    moveNodes(editor, {\n      at: dragPath,\n      to,\n    });\n  }\n};\n","import type { DropTargetMonitor, XYCoord } from 'react-dnd';\n\nimport type { DragItemNode, DropDirection } from '../types';\n\nexport interface GetHoverDirectionOptions {\n  dragItem: DragItemNode;\n\n  /** Hovering node id. */\n  id: string;\n\n  monitor: DropTargetMonitor;\n\n  /** The node ref of the node being dragged. */\n  nodeRef: any;\n}\n\n/**\n * If dragging a node A over another node B: get the direction of node A\n * relative to node B.\n */\nexport const getHoverDirection = ({\n  dragItem,\n  id,\n  monitor,\n  nodeRef,\n}: GetHoverDirectionOptions): DropDirection => {\n  if (!nodeRef.current) return;\n\n  const dragId = dragItem.id;\n\n  // Don't replace items with themselves\n  if (dragId === id) return;\n\n  // Determine rectangle on screen\n  const hoverBoundingRect = nodeRef.current?.getBoundingClientRect();\n\n  // Get vertical middle\n  const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;\n\n  // Determine mouse position\n  const clientOffset = monitor.getClientOffset();\n\n  if (!clientOffset) return;\n\n  // Get pixels to the top\n  const hoverClientY = (clientOffset as XYCoord).y - hoverBoundingRect.top;\n\n  // Only perform the move when the mouse has crossed half of the items height\n  // When dragging downwards, only move when the cursor is below 50%\n  // When dragging upwards, only move when the cursor is above 50%\n\n  // Dragging downwards\n  // if (dragId < hoverId && hoverClientY < hoverMiddleY) {\n  if (hoverClientY < hoverMiddleY) {\n    return 'top';\n  }\n  // Dragging upwards\n  // if (dragId > hoverId && hoverClientY > hoverMiddleY) {\n  if (hoverClientY >= hoverMiddleY) {\n    return 'bottom';\n  }\n};\n","/** Get new direction if updated */\nimport type { DropLineDirection } from '../types';\n\nexport const getNewDirection = (\n  previousDir: string,\n  dir?: string\n): DropLineDirection | undefined => {\n  if (!dir && previousDir) {\n    return '';\n  }\n  if (dir === 'top' && previousDir !== 'top') {\n    return 'top';\n  }\n  if (dir === 'bottom' && previousDir !== 'bottom') {\n    return 'bottom';\n  }\n};\n","import type { DropTargetMonitor } from 'react-dnd';\n\nimport { type TReactEditor, focusEditor } from '@udecode/plate-common';\nimport {\n  type Value,\n  collapseSelection,\n  isExpanded,\n} from '@udecode/plate-common/server';\n\nimport type { UseDropNodeOptions } from '../hooks/useDropNode';\nimport type { DragItemNode } from '../types';\n\nimport { getHoverDirection, getNewDirection } from '../utils';\n\n/** Callback called when dragging a node and hovering nodes. */\nexport const onHoverNode = <V extends Value>(\n  editor: TReactEditor<V>,\n  {\n    dragItem,\n    dropLine,\n    id,\n    monitor,\n    nodeRef,\n    onChangeDropLine,\n  }: {\n    dragItem: DragItemNode;\n    monitor: DropTargetMonitor;\n  } & Pick<\n    UseDropNodeOptions,\n    'dropLine' | 'id' | 'nodeRef' | 'onChangeDropLine'\n  >\n) => {\n  const direction = getHoverDirection({\n    dragItem,\n    id,\n    monitor,\n    nodeRef,\n  });\n  const dropLineDir = getNewDirection(dropLine, direction);\n\n  if (dropLineDir) onChangeDropLine(dropLineDir);\n  if (direction && isExpanded(editor.selection)) {\n    focusEditor(editor);\n    collapseSelection(editor);\n  }\n};\n","import type { TEditor, Value } from '@udecode/plate-common/server';\n\nimport { useDragNode } from './useDragNode';\n\nexport const DRAG_ITEM_BLOCK = 'block';\n\n/** {@link useDragNode} */\nexport const useDragBlock = <V extends Value>(editor: TEditor<V>, id: string) =>\n  useDragNode<V>(editor, {\n    id,\n    type: DRAG_ITEM_BLOCK,\n  });\n","import type { WithPartial } from '@udecode/plate-common/server';\n\nimport { type UseDndNodeOptions, useDndNode } from './useDndNode';\nimport { DRAG_ITEM_BLOCK } from './useDragBlock';\n\n/** {@link useDndNode} */\nexport const useDndBlock = (options: WithPartial<UseDndNodeOptions, 'type'>) =>\n  useDndNode({\n    type: DRAG_ITEM_BLOCK,\n    ...options,\n  });\n","import type { TReactEditor } from '@udecode/plate-common';\nimport type { Value } from '@udecode/plate-common/server';\n\nimport { DRAG_ITEM_BLOCK } from './useDragBlock';\nimport { type UseDropNodeOptions, useDropNode } from './useDropNode';\n\n/** {@link useDropNode} */\nexport const useDropBlock = <V extends Value>(\n  editor: TReactEditor<V>,\n  options: Omit<UseDropNodeOptions, 'accept'>\n) => useDropNode(editor, { accept: DRAG_ITEM_BLOCK, ...options });\n","import {\n  type GetNodeEntriesOptions,\n  type TEditor,\n  type Value,\n  getNodeEntries,\n  isBlock,\n} from '@udecode/plate-common/server';\n\n/** Get blocks with an id */\nexport const getBlocksWithId = <V extends Value>(\n  editor: TEditor<V>,\n  options: GetNodeEntriesOptions<V>\n) => {\n  const _nodes = getNodeEntries(editor, {\n    match: (n) => isBlock(editor, n) && !!n.id,\n    ...options,\n  });\n\n  return Array.from(_nodes);\n};\n","import {\n  type TEditor,\n  type TNodeEntry,\n  type Value,\n  getRange,\n} from '@udecode/plate-common/server';\n\n/** Get node entries range. */\nexport const getNodesRange = <V extends Value>(\n  editor: TEditor<V>,\n  nodeEntries: TNodeEntry[]\n) => {\n  if (nodeEntries.length === 0) return;\n\n  const firstBlockPath = nodeEntries[0][1];\n  const lastBlockPath = nodeEntries.at(-1)![1];\n\n  return getRange(editor, firstBlockPath, lastBlockPath);\n};\n","import { type TReactEditor, focusEditor } from '@udecode/plate-common';\nimport {\n  type Value,\n  findNode,\n  getStartPoint,\n  select,\n} from '@udecode/plate-common/server';\n\n/** Select the start of a block by id and focus the editor. */\nexport const focusBlockStartById = <V extends Value>(\n  editor: TReactEditor<V>,\n  id: string\n) => {\n  const path = findNode(editor, { at: [], match: { id } })?.[1];\n\n  if (!path) return;\n\n  select(editor, getStartPoint(editor, path));\n  focusEditor(editor);\n};\n","import { type TReactEditor, focusEditor } from '@udecode/plate-common';\nimport {\n  type GetNodeEntriesOptions,\n  type Value,\n  removeNodes,\n  unhangRange,\n} from '@udecode/plate-common/server';\n\nimport { getBlocksWithId } from '../queries/getBlocksWithId';\nimport { getNodesRange } from '../queries/getNodesRange';\n\n/** Remove blocks with an id and focus the editor. */\nexport const removeBlocksAndFocus = <V extends Value>(\n  editor: TReactEditor<V>,\n  options: GetNodeEntriesOptions<V>\n) => {\n  unhangRange(editor, options?.at, options);\n\n  const nodeEntries = getBlocksWithId(editor, options);\n\n  removeNodes(editor, { at: getNodesRange(editor, nodeEntries) });\n  focusEditor(editor);\n};\n","import { type TReactEditor, focusEditor } from '@udecode/plate-common';\nimport {\n  type Value,\n  findNode,\n  getRange,\n  select,\n} from '@udecode/plate-common/server';\n\n/** Select the block above the selection by id and focus the editor. */\nexport const selectBlockById = <V extends Value>(\n  editor: TReactEditor<V>,\n  id: string\n) => {\n  const path = findNode(editor, { at: [], match: { id } })?.[1];\n\n  if (!path) return;\n\n  select(editor, getRange(editor, path));\n  focusEditor(editor);\n};\n","import type { Range } from 'slate';\n\nimport { focusEditor } from '@udecode/plate-common';\nimport {\n  type PlateEditor,\n  type Value,\n  select,\n} from '@udecode/plate-common/server';\n\nimport { getBlocksWithId } from '../queries/getBlocksWithId';\nimport { getNodesRange } from '../queries/getNodesRange';\nimport { selectBlockById } from './selectBlockById';\n\n/**\n * Select blocks by selection or by id. If the block with id is not selected,\n * select the block with id. Else, select the blocks above the selection.\n */\nexport const selectBlocksBySelectionOrId = <V extends Value>(\n  editor: PlateEditor<V>,\n  id: string\n) => {\n  if (!editor.selection) return;\n\n  const blockEntries = getBlocksWithId(editor, { at: editor.selection });\n  const isBlockSelected = blockEntries.some(\n    (blockEntry) => blockEntry[0].id === id\n  );\n\n  if (isBlockSelected) {\n    select(editor, getNodesRange(editor, blockEntries) as Range);\n    focusEditor(editor);\n  } else {\n    selectBlockById(editor, id);\n  }\n};\n"],"mappings":"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","names":["import_react","import_server","import_react","import_react","React","raf","throttle","React","React","React","import_react","React","import_react","React","import_react","React","import_react","import_plate_common","import_react_dnd","import_plate_common","import_server","import_plate_common","import_server","React","import_server","import_server","import_plate_common","import_server","import_plate_common","import_server","import_plate_common","import_server","import_plate_common","import_server"]}