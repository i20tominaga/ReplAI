import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { TElement, TEditor, PlateRenderElementProps, AnyObject, Value, WithPartial, GetNodeEntriesOptions, TNodeEntry, PlateEditor } from '@udecode/plate-common/server';
import * as _udecode_slate from '@udecode/slate';
import React from 'react';
import * as zustand_x from 'zustand-x';
import * as react_dnd from 'react-dnd';
import { DropTargetMonitor, DragSourceHookSpec, DropTargetHookSpec } from 'react-dnd';
import * as _udecode_plate_common from '@udecode/plate-common';
import { TReactEditor } from '@udecode/plate-common';
import * as slate from 'slate';
import { Path } from 'slate';
import * as slate_react from 'slate-react';

interface ScrollAreaProps {
    placement: 'bottom' | 'top';
    containerRef?: React.RefObject<any>;
    enabled?: boolean;
    height?: number;
    minStrength?: number;
    scrollAreaProps?: React.HTMLAttributes<HTMLDivElement>;
    strengthMultiplier?: number;
    zIndex?: number;
}
declare function ScrollArea({ containerRef, enabled, height, minStrength, placement, scrollAreaProps, strengthMultiplier, zIndex, }: ScrollAreaProps): React.JSX.Element | null;

type ScrollerProps = Omit<ScrollAreaProps, 'placement'>;
/**
 * Set up an edge scroller at the top of the page for scrolling up. One at the
 * bottom for scrolling down.
 */
declare function Scroller(props: ScrollerProps): React.JSX.Element;

declare function DndScroller(props: Partial<ScrollerProps>): React.JSX.Element;

interface DndPlugin {
    enableScroller?: boolean;
    scrollerProps?: Partial<ScrollerProps>;
}
declare const KEY_DND = "dnd";
declare const createDndPlugin: <OP = DndPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const dndStore: zustand_x.StoreApi<"dnd", {
    isDragging: boolean;
}, zustand_x.StateActions<{
    isDragging: boolean;
}>, {}>;

interface DragItemNode {
    [key: string]: unknown;
    /** Required to identify the node. */
    id: string;
}
type DropLineDirection = '' | 'bottom' | 'top';
type DropDirection = 'bottom' | 'top' | undefined;

type DraggableState = {
    dragRef: (elementOrNode: Element | React.ReactElement | React.RefObject<any> | null) => void;
    dropLine: DropLineDirection;
    isDragging: boolean;
    isHovered: boolean;
    nodeRef: React.RefObject<HTMLDivElement>;
    setIsHovered: (isHovered: boolean) => void;
};
declare const useDraggableState: (props: {
    element: TElement;
    onDropHandler?: ((editor: TEditor, props: {
        dragItem: DragItemNode;
        id: string;
        monitor: DropTargetMonitor<DragItemNode, unknown>;
        nodeRef: any;
    }) => boolean) | undefined;
}) => DraggableState;
declare const useDraggable: (state: DraggableState) => {
    droplineProps: {
        contentEditable: boolean;
    };
    groupProps: {
        onPointerEnter: () => void;
        onPointerLeave: () => void;
    };
    gutterLeftProps: {
        contentEditable: boolean;
    };
    handleRef: (elementOrNode: Element | React.ReactElement | React.RefObject<any> | null) => void;
    previewRef: React.RefObject<HTMLDivElement>;
};

interface WithDraggableOptions<T = any> {
    /** Enables dnd in read-only. */
    allowReadOnly?: boolean;
    draggableProps?: T;
    /** Filter out elements that can't be dragged. */
    filter?: (editor: TEditor, path: Path) => boolean;
    /**
     * Document level where dnd is enabled. 0 = root blocks, 1 = first level of
     * children, etc. Set to null to allow all levels.
     *
     * @default 0
     */
    level?: null | number;
}
declare const useWithDraggable: <T = any>({ allowReadOnly, draggableProps, editor, element, filter, level, }: PlateRenderElementProps & WithDraggableOptions<T>) => {
    disabled: boolean;
    draggableProps: {
        editor: _udecode_plate_common.PlateEditor<_udecode_slate.Value>;
        element: _udecode_slate.TElement;
    };
};

declare const withDraggable: <T extends AnyObject = AnyObject>(Draggable: React.FC<any>, Component: React.FC<any>, options?: WithDraggableOptions<T>) => React.ForwardRefExoticComponent<_udecode_plate_common_server.PlateRenderNodeProps<_udecode_slate.Value, _udecode_plate_common_server.PlateEditor<_udecode_slate.Value>> & {
    element: _udecode_slate.TElement;
} & Omit<slate_react.RenderElementProps, "element"> & React.RefAttributes<HTMLDivElement>>;

interface UseDragNodeOptions extends DragSourceHookSpec<DragItemNode, unknown, {
    isDragging: boolean;
}> {
    id: string;
}
/**
 * `useDrag` hook to drag a node from the editor. `item` with `id` is required.
 *
 * On drag start:
 *
 * - Set `editor.isDragging` to true
 * - Add `dragging` class to `body`
 *
 * On drag end:
 *
 * - Set `editor.isDragging` to false
 * - Remove `dragging` class to `body`
 *
 * Collect:
 *
 * - IsDragging: true if mouse is dragging the block
 */
declare const useDragNode: <V extends Value>(editor: TEditor<V>, { id, item, ...options }: UseDragNodeOptions) => [{
    isDragging: boolean;
}, react_dnd.ConnectDragSource, react_dnd.ConnectDragPreview];

interface UseDropNodeOptions extends DropTargetHookSpec<DragItemNode, unknown, {
    isOver: boolean;
}> {
    /** Current value of dropLine. */
    dropLine: string;
    /** Id of the node. */
    id: string;
    /** The reference to the node being dragged. */
    nodeRef: any;
    /** Callback called on dropLine change. */
    onChangeDropLine: (newValue: DropLineDirection) => void;
    /**
     * Intercepts the drop handling. If `false` is returned, the default drop
     * behavior is called after. If `true` is returned, the default behavior is
     * not called.
     */
    onDropHandler?: (editor: TEditor, props: {
        dragItem: DragItemNode;
        id: string;
        monitor: DropTargetMonitor<DragItemNode, unknown>;
        nodeRef: any;
    }) => boolean;
}
/**
 * `useDrop` hook to drop a node on the editor.
 *
 * On drop:
 *
 * - Get hover direction (top, bottom or undefined), return early if undefined
 * - DragPath: find node with id = dragItem.id, return early if not found
 * - Focus editor
 * - DropPath: find node with id = id, its path should be next (bottom) or
 *   previous (top)
 * - Move node from dragPath to dropPath
 *
 * On hover:
 *
 * - Get drop line direction
 * - If differs from dropLine, setDropLine is called
 *
 * Collect:
 *
 * - IsOver: true if mouse is over the block
 */
declare const useDropNode: <V extends Value>(editor: TReactEditor<V>, { dropLine, id, nodeRef, onChangeDropLine, onDropHandler, ...options }: UseDropNodeOptions) => [{
    isOver: boolean;
}, react_dnd.ConnectDropTarget];

interface UseDndNodeOptions extends Pick<UseDropNodeOptions, 'id' | 'nodeRef'>, Pick<UseDragNodeOptions, 'type'> {
    drag?: UseDragNodeOptions;
    drop?: UseDropNodeOptions;
    onDropHandler?: (editor: TEditor, props: {
        dragItem: DragItemNode;
        id: string;
        monitor: DropTargetMonitor<DragItemNode, unknown>;
        nodeRef: any;
    }) => boolean;
    preview?: {
        /** Whether to disable the preview. */
        disable?: boolean;
        /** The reference to the preview element. */
        ref?: any;
    };
}
/**
 * {@link useDragNode} and {@link useDropNode} hooks to drag and drop a node from
 * the editor. A default preview is used to show the node being dragged, which
 * can be customized or removed. Returns the drag ref and drop line direction.
 */
declare const useDndNode: ({ drag: dragOptions, drop: dropOptions, id, nodeRef, onDropHandler, preview: previewOptions, type, }: UseDndNodeOptions) => {
    dragRef: react_dnd.ConnectDragSource;
    dropLine: DropLineDirection;
    isDragging: boolean;
    isOver: boolean;
};

/** {@link useDndNode} */
declare const useDndBlock: (options: WithPartial<UseDndNodeOptions, 'type'>) => {
    dragRef: react_dnd.ConnectDragSource;
    dropLine: DropLineDirection;
    isDragging: boolean;
    isOver: boolean;
};

declare const DRAG_ITEM_BLOCK = "block";
/** {@link useDragNode} */
declare const useDragBlock: <V extends Value>(editor: TEditor<V>, id: string) => [{
    isDragging: boolean;
}, react_dnd.ConnectDragSource, react_dnd.ConnectDragPreview];

/** {@link useDropNode} */
declare const useDropBlock: <V extends Value>(editor: TReactEditor<V>, options: Omit<UseDropNodeOptions, 'accept'>) => [{
    isOver: boolean;
}, react_dnd.ConnectDropTarget];

/** Get blocks with an id */
declare const getBlocksWithId: <V extends Value>(editor: TEditor<V>, options: GetNodeEntriesOptions<V>) => _udecode_slate.TNodeEntry<_udecode_slate.ENode<V>>[];

/** Get node entries range. */
declare const getNodesRange: <V extends Value>(editor: TEditor<V>, nodeEntries: TNodeEntry[]) => slate.BaseRange | undefined;

/** Select the start of a block by id and focus the editor. */
declare const focusBlockStartById: <V extends Value>(editor: TReactEditor<V>, id: string) => void;

/** Callback called on drag an drop a node with id. */
declare const onDropNode: <V extends Value>(editor: TReactEditor<V>, { dragItem, id, monitor, nodeRef, }: {
    dragItem: DragItemNode;
    monitor: DropTargetMonitor;
} & Pick<UseDropNodeOptions, "id" | "nodeRef">) => void;

/** Callback called when dragging a node and hovering nodes. */
declare const onHoverNode: <V extends Value>(editor: TReactEditor<V>, { dragItem, dropLine, id, monitor, nodeRef, onChangeDropLine, }: {
    dragItem: DragItemNode;
    monitor: DropTargetMonitor;
} & Pick<UseDropNodeOptions, "id" | "nodeRef" | "dropLine" | "onChangeDropLine">) => void;

/** Remove blocks with an id and focus the editor. */
declare const removeBlocksAndFocus: <V extends Value>(editor: TReactEditor<V>, options: GetNodeEntriesOptions<V>) => void;

/** Select the block above the selection by id and focus the editor. */
declare const selectBlockById: <V extends Value>(editor: TReactEditor<V>, id: string) => void;

/**
 * Select blocks by selection or by id. If the block with id is not selected,
 * select the block with id. Else, select the blocks above the selection.
 */
declare const selectBlocksBySelectionOrId: <V extends Value>(editor: PlateEditor<V>, id: string) => void;

interface GetHoverDirectionOptions {
    dragItem: DragItemNode;
    /** Hovering node id. */
    id: string;
    monitor: DropTargetMonitor;
    /** The node ref of the node being dragged. */
    nodeRef: any;
}
/**
 * If dragging a node A over another node B: get the direction of node A
 * relative to node B.
 */
declare const getHoverDirection: ({ dragItem, id, monitor, nodeRef, }: GetHoverDirectionOptions) => DropDirection;

/** Get new direction if updated */

declare const getNewDirection: (previousDir: string, dir?: string) => DropLineDirection | undefined;

export { DRAG_ITEM_BLOCK, type DndPlugin, DndScroller, type DragItemNode, type DraggableState, type DropDirection, type DropLineDirection, type GetHoverDirectionOptions, KEY_DND, ScrollArea, type ScrollAreaProps, Scroller, type ScrollerProps, type UseDndNodeOptions, type UseDragNodeOptions, type UseDropNodeOptions, type WithDraggableOptions, createDndPlugin, dndStore, focusBlockStartById, getBlocksWithId, getHoverDirection, getNewDirection, getNodesRange, onDropNode, onHoverNode, removeBlocksAndFocus, selectBlockById, selectBlocksBySelectionOrId, useDndBlock, useDndNode, useDragBlock, useDragNode, useDraggable, useDraggableState, useDropBlock, useDropNode, useWithDraggable, withDraggable };
