import * as zustand_x from 'zustand-x';
import * as slate from 'slate';
import { Range, Point } from 'slate';
import * as _udecode_plate_common from '@udecode/plate-common';
import { Value, PlateEditor, ZustandStoreApi, ZustandStateActions, KeyboardHandlerReturnType, TEditor } from '@udecode/plate-common';
import * as _udecode_slate from '@udecode/slate';
import * as _udecode_utils from '@udecode/utils';
import * as downshift from 'downshift';
import React from 'react';

interface TComboboxItemBase {
    /** Unique key. */
    key: string;
    /** Item text. */
    text: any;
    /**
     * Whether the item is disabled.
     *
     * @default false
     */
    disabled?: boolean;
}
interface TComboboxItemWithData<TData extends Data> extends TComboboxItemBase {
    /** Data available to `onRenderItem`. */
    data: TData;
}
type NoData = undefined;
type Data = unknown;
type TComboboxItem<TData = NoData> = TData extends NoData ? TComboboxItemBase : TComboboxItemWithData<TData>;
type ComboboxOnSelectItem<TData> = <V extends Value>(editor: PlateEditor<V>, item: TComboboxItem<TData>) => any;

interface ComboboxProps<TData = NoData> extends Partial<Pick<ComboboxState<TData>, 'items'>>, ComboboxStateById<TData> {
    /** Render this component when the combobox is open (useful to inject hooks). */
    component?: React.FC<{
        store: ComboboxStoreById;
    }>;
    /**
     * Whether to hide the combobox.
     *
     * @default !items.length
     */
    disabled?: boolean;
    /**
     * Render combobox item.
     *
     * @default text
     */
    onRenderItem?: React.FC<ComboboxItemProps<any>>;
    portalElement?: HTMLElement;
}

type ComboboxStateById<TData = NoData> = {
    /** Is opening/closing the combobox controlled by the client. */
    controlled?: boolean;
    /**
     * Items filter function by text.
     *
     * @default (value) => value.text.toLowerCase().startsWith(search.toLowerCase())
     */
    filter?: (search: string) => (item: TComboboxItem<TData>) => boolean;
    /** Combobox id. */
    id: string;
    /**
     * Max number of items.
     *
     * @default items.length
     */
    maxSuggestions?: number;
    /** Called when an item is selected. */
    onSelectItem: ComboboxOnSelectItem<TData> | null;
    /** Regular expression for search, for example to allow whitespace */
    searchPattern?: string;
    /** Sort filtered items before applying maxSuggestions. */
    sort?: (search: string) => (a: TComboboxItem<TData>, b: TComboboxItem<TData>) => number;
    /** Trigger that activates the combobox. */
    trigger: string;
};
type ComboboxStoreById<TData = NoData> = ZustandStoreApi<string, ComboboxStateById<TData>, ZustandStateActions<ComboboxStateById<TData>>>;
type ComboboxState<TData = NoData> = {
    /** Active id (combobox id which is opened). */
    activeId: null | string;
    /**
     * Object whose keys are combobox ids and values are config stores (e.g. one
     * for tag, one for mention,...).
     */
    byId: Record<string, ComboboxStoreById>;
    /** Filtered items */
    filteredItems: TComboboxItem<TData>[];
    /** Highlighted index. */
    highlightedIndex: number;
    /** Unfiltered items. */
    items: TComboboxItem<TData>[];
    /** Range from the trigger to the cursor. */
    targetRange: Range | null;
    /** Text after the trigger. */
    text: null | string;
};
declare const comboboxStore: ZustandStoreApi<"combobox", ComboboxState<undefined>, zustand_x.SetRecord<ComboboxState<undefined>> & {
    state: zustand_x.SetImmerState<ComboboxState<undefined>>;
    mergeState: zustand_x.MergeState<ComboboxState<undefined>>;
} & {
    open: (state: Pick<ComboboxState, 'activeId' | 'targetRange' | 'text'>) => void;
    reset: () => void;
    setComboboxById: <TData = undefined>(state: ComboboxStateById<TData>) => void;
}, {
    isOpen: () => boolean;
}>;
declare const useComboboxSelectors: zustand_x.StoreApiUse<ComboboxState<undefined>, {
    isOpen: () => boolean;
}>;
declare const comboboxSelectors: zustand_x.StoreApiGet<ComboboxState<undefined>, {
    isOpen: () => boolean;
}>;
declare const comboboxActions: zustand_x.SetRecord<ComboboxState<undefined>> & {
    state: zustand_x.SetImmerState<ComboboxState<undefined>>;
    mergeState: zustand_x.MergeState<ComboboxState<undefined>>;
} & {
    open: (state: Pick<ComboboxState, 'activeId' | 'targetRange' | 'text'>) => void;
    reset: () => void;
    setComboboxById: <TData = undefined>(state: ComboboxStateById<TData>) => void;
};
declare const getComboboxStoreById: (id: null | string) => ComboboxStoreById<undefined> | null;
declare const useActiveComboboxStore: () => ComboboxStoreById<undefined> | null;

declare const KEY_COMBOBOX = "combobox";
declare const createComboboxPlugin: <OP = _udecode_utils.AnyObject, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common.PlateEditor<OV> = _udecode_plate_common.PlateEditor<OV>>(override?: Partial<_udecode_plate_common.PlatePlugin<_udecode_plate_common.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common.PlatePlugin<_udecode_plate_common.NoInfer<OP>, OV, OE>;

/**
 * For each combobox state (byId):
 *
 * - If the selection is collapsed
 * - If the cursor follows the trigger
 * - If there is text without whitespaces after the trigger
 * - Open the combobox: set id, search, targetRange in the store Close the
 *   combobox if needed
 */
declare const onChangeCombobox: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => () => void;

/**
 * If the combobox is open, handle:
 *
 * - Down (next item)
 * - Up (previous item)
 * - Escape (reset combobox)
 * - Tab, enter (select item)
 */
declare const onKeyDownCombobox: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => KeyboardHandlerReturnType;

type ComboboxContentProps<TData extends Data = NoData> = {
    combobox: ComboboxControls;
} & Omit<ComboboxProps<TData>, 'controlled' | 'filter' | 'id' | 'maxSuggestions' | 'onSelectItem' | 'searchPattern' | 'sort' | 'trigger'>;
type ComboboxContentRootProps<TData extends Data = NoData> = {
    combobox: ComboboxControls;
} & ComboboxContentProps<TData>;
declare const useComboboxContentState: <TData extends unknown = undefined>({ combobox, items, }: ComboboxContentRootProps<TData>) => {
    combobox: {
        closeMenu: () => void;
        getItemProps: (options: downshift.UseComboboxGetItemPropsOptions<TComboboxItemBase>) => any;
        getMenuProps: (options?: downshift.UseComboboxGetMenuPropsOptions | undefined, otherOptions?: downshift.GetPropsCommonOptions | undefined) => any;
    };
    targetRange: slate.BaseRange | null;
};
declare const useComboboxContent: (state: ReturnType<typeof useComboboxContentState>) => {
    menuProps: any;
    targetRange: slate.BaseRange | null;
};

type ComboboxControls = ReturnType<typeof useComboboxControls>;
declare const useComboboxControls: () => {
    closeMenu: () => void;
    getItemProps: (options: downshift.UseComboboxGetItemPropsOptions<TComboboxItemBase>) => any;
    getMenuProps: (options?: downshift.UseComboboxGetMenuPropsOptions | undefined, otherOptions?: downshift.GetPropsCommonOptions | undefined) => any;
};

type ComboboxContentItemProps<TData extends Data = NoData> = {
    combobox: ComboboxControls;
    index: number;
    item: TComboboxItem<TData>;
} & Pick<ComboboxContentProps<TData>, 'onRenderItem'>;
interface ComboboxItemProps<TData extends Data = NoData> {
    item: TComboboxItem<TData>;
    search: string;
}
declare const useComboboxItem: <TData extends unknown = undefined>({ combobox, index, item, onRenderItem, }: ComboboxContentItemProps<TData>) => {
    props: any;
};

/**
 * Returns the next index in the list of an item that is not disabled.
 *
 * @param {number} moveAmount Number of positions to move. Negative to move
 *   backwards, positive forwards.
 * @param {number} baseIndex The initial position to move from.
 * @param {number} itemCount The total number of items.
 * @param {Function} getItemNodeFromIndex Used to check if item is disabled.
 * @param {boolean} circular Specify if navigation is circular. Default is true.
 * @returns {number} The new index. Returns baseIndex if item is not disabled.
 *   Returns next non-disabled item otherwise. If no non-disabled found it will
 *   return -1.
 */
declare const getNextNonDisabledIndex: (moveAmount: number, baseIndex: number, itemCount: number, getItemNodeFromIndex: any, circular: boolean) => number;

/**
 * Returns the new index in the list, in a circular way. If next value is out of
 * bonds from the total, it will wrap to either 0 or itemCount - 1.
 *
 * @param {number} moveAmount Number of positions to move. Negative to move
 *   backwards, positive forwards.
 * @param {number} baseIndex The initial position to move from.
 * @param {number} itemCount The total number of items.
 * @param {Function} getItemNodeFromIndex Used to check if item is disabled.
 * @param {boolean} circular Specify if navigation is circular. Default is true.
 * @returns {number} The new index after the move.
 */
declare const getNextWrappingIndex: (moveAmount: number, baseIndex: number, itemCount: number, getItemNodeFromIndex: any, circular?: boolean) => number;

/**
 * Get text and range from trigger to cursor. Starts with trigger and ends with
 * non-whitespace character.
 */
declare const getTextFromTrigger: <V extends Value>(editor: TEditor<V>, { at, searchPattern, trigger, }: {
    at: Point;
    searchPattern?: string | undefined;
    trigger: string;
}) => {
    range: slate.BaseRange;
    textAfterTrigger: string;
} | undefined;

export { type ComboboxContentItemProps, type ComboboxContentProps, type ComboboxContentRootProps, type ComboboxControls, type ComboboxItemProps, type ComboboxOnSelectItem, type ComboboxProps, type ComboboxState, type ComboboxStateById, type ComboboxStoreById, type Data, KEY_COMBOBOX, type NoData, type TComboboxItem, type TComboboxItemBase, type TComboboxItemWithData, comboboxActions, comboboxSelectors, comboboxStore, createComboboxPlugin, getComboboxStoreById, getNextNonDisabledIndex, getNextWrappingIndex, getTextFromTrigger, onChangeCombobox, onKeyDownCombobox, useActiveComboboxStore, useComboboxContent, useComboboxContentState, useComboboxControls, useComboboxItem, useComboboxSelectors };
