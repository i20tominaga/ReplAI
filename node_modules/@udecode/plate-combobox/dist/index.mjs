var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/combobox.store.ts
import {
  createZustandStore
} from "@udecode/plate-common";
var createComboboxStore = (state) => createZustandStore(`combobox-${state.id}`)(state);
var comboboxStore = createZustandStore("combobox")({
  activeId: null,
  byId: {},
  filteredItems: [],
  highlightedIndex: 0,
  items: [],
  targetRange: null,
  text: null
}).extendActions((set, get) => ({
  open: (state) => {
    set.mergeState(state);
  },
  reset: () => {
    set.state((draft) => {
      draft.activeId = null;
      draft.highlightedIndex = 0;
      draft.filteredItems = [];
      draft.items = [];
      draft.text = null;
      draft.targetRange = null;
    });
  },
  setComboboxById: (state) => {
    if (get.byId()[state.id])
      return;
    set.state((draft) => {
      draft.byId[state.id] = createComboboxStore(
        state
      );
    });
  }
})).extendSelectors((state) => ({
  isOpen: () => !!state.activeId
}));
var useComboboxSelectors = comboboxStore.use;
var comboboxSelectors = comboboxStore.get;
var comboboxActions = comboboxStore.set;
var getComboboxStoreById = (id) => id ? comboboxSelectors.byId()[id] : null;
var useActiveComboboxStore = () => {
  const activeId = useComboboxSelectors.activeId();
  const comboboxes = useComboboxSelectors.byId();
  return activeId ? comboboxes[activeId] : null;
};

// src/createComboboxPlugin.ts
import { createPluginFactory } from "@udecode/plate-common";

// src/onChangeCombobox.ts
import {
  isCollapsed
} from "@udecode/plate-common";
import { Range } from "slate";

// src/utils/getTextFromTrigger.ts
import {
  escapeRegExp,
  getEditorString,
  getPointBefore,
  getRange
} from "@udecode/plate-common";
var getTextFromTrigger = (editor, {
  at,
  searchPattern = `\\S+`,
  trigger
}) => {
  const escapedTrigger = escapeRegExp(trigger);
  const triggerRegex = new RegExp(`(?:^|\\s)${escapedTrigger}`);
  let start = at;
  let end;
  while (true) {
    end = start;
    if (!start)
      break;
    start = getPointBefore(editor, start);
    const charRange = start && getRange(editor, start, end);
    const charText = getEditorString(editor, charRange);
    if (!charText.match(searchPattern)) {
      start = end;
      break;
    }
  }
  const range = start && getRange(editor, start, at);
  const text = getEditorString(editor, range);
  if (!range || !text.match(triggerRegex))
    return;
  return {
    range,
    textAfterTrigger: text.slice(trigger.length)
  };
};

// src/onChangeCombobox.ts
var onChangeCombobox = (editor) => () => {
  var _a, _b, _c, _d;
  const byId = comboboxSelectors.byId();
  const activeId = comboboxSelectors.activeId();
  let shouldClose = true;
  for (const store of Object.values(byId)) {
    const id = store.get.id();
    const controlled = (_b = (_a = store.get).controlled) == null ? void 0 : _b.call(_a);
    if (controlled) {
      if (activeId === id) {
        shouldClose = false;
        break;
      } else {
        continue;
      }
    }
    const { selection } = editor;
    if (!selection || !isCollapsed(selection)) {
      continue;
    }
    const trigger = store.get.trigger();
    const searchPattern = (_d = (_c = store.get).searchPattern) == null ? void 0 : _d.call(_c);
    const isCursorAfterTrigger = getTextFromTrigger(editor, {
      at: Range.start(selection),
      searchPattern,
      trigger
    });
    if (!isCursorAfterTrigger) {
      continue;
    }
    const { range, textAfterTrigger } = isCursorAfterTrigger;
    comboboxActions.open({
      activeId: id,
      targetRange: range,
      text: textAfterTrigger
    });
    shouldClose = false;
    break;
  }
  if (shouldClose && comboboxSelectors.isOpen()) {
    comboboxActions.reset();
  }
};

// src/onKeyDownCombobox.ts
import {
  Hotkeys,
  isHotkey
} from "@udecode/plate-common";

// src/utils/getNextNonDisabledIndex.ts
var getNextNonDisabledIndex = (moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) => {
  const currentElementNode = getItemNodeFromIndex(baseIndex);
  if (!(currentElementNode == null ? void 0 : currentElementNode.hasAttribute("disabled"))) {
    return baseIndex;
  }
  if (moveAmount > 0) {
    for (let index = baseIndex + 1; index < itemCount; index++) {
      if (!getItemNodeFromIndex(index).hasAttribute("disabled")) {
        return index;
      }
    }
  } else {
    for (let index = baseIndex - 1; index >= 0; index--) {
      if (!getItemNodeFromIndex(index).hasAttribute("disabled")) {
        return index;
      }
    }
  }
  if (circular) {
    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(
      -1,
      itemCount - 1,
      itemCount,
      getItemNodeFromIndex,
      false
    );
  }
  return -1;
};

// src/utils/getNextWrappingIndex.ts
var getNextWrappingIndex = (moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular = true) => {
  if (itemCount === 0) {
    return -1;
  }
  const itemsLastIndex = itemCount - 1;
  if (typeof baseIndex !== "number" || baseIndex < 0 || baseIndex >= itemCount) {
    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
  }
  let newIndex = baseIndex + moveAmount;
  if (newIndex < 0) {
    newIndex = circular ? itemsLastIndex : 0;
  } else if (newIndex > itemsLastIndex) {
    newIndex = circular ? 0 : itemsLastIndex;
  }
  const nonDisabledNewIndex = getNextNonDisabledIndex(
    moveAmount,
    newIndex,
    itemCount,
    getItemNodeFromIndex,
    circular
  );
  if (nonDisabledNewIndex === -1) {
    return baseIndex >= itemCount ? -1 : baseIndex;
  }
  return nonDisabledNewIndex;
};

// src/onKeyDownCombobox.ts
var onKeyDownCombobox = (editor) => (event) => {
  const { activeId, filteredItems, highlightedIndex } = comboboxSelectors.state();
  const isOpen = comboboxSelectors.isOpen();
  if (!isOpen)
    return;
  const store = getComboboxStoreById(activeId);
  if (!store)
    return;
  const onSelectItem = store.get.onSelectItem();
  if (isHotkey("down", event)) {
    event.preventDefault();
    const newIndex = getNextWrappingIndex(
      1,
      highlightedIndex,
      filteredItems.length,
      () => {
      },
      true
    );
    comboboxActions.highlightedIndex(newIndex);
    return;
  }
  if (isHotkey("up", event)) {
    event.preventDefault();
    const newIndex = getNextWrappingIndex(
      -1,
      highlightedIndex,
      filteredItems.length,
      () => {
      },
      true
    );
    comboboxActions.highlightedIndex(newIndex);
    return;
  }
  if (isHotkey("escape", event)) {
    event.preventDefault();
    comboboxActions.reset();
    return;
  }
  if (Hotkeys.isTab(editor, event) || isHotkey("enter", event)) {
    event.preventDefault();
    event.stopPropagation();
    if (filteredItems[highlightedIndex]) {
      onSelectItem == null ? void 0 : onSelectItem(editor, filteredItems[highlightedIndex]);
    }
  }
};

// src/createComboboxPlugin.ts
var KEY_COMBOBOX = "combobox";
var createComboboxPlugin = createPluginFactory({
  handlers: {
    onChange: onChangeCombobox,
    onKeyDown: onKeyDownCombobox
  },
  key: KEY_COMBOBOX
});

// src/hooks/useComboboxContent.ts
import React from "react";
var useComboboxContentState = ({
  combobox,
  items
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const targetRange = useComboboxSelectors.targetRange();
  const activeComboboxStore = useActiveComboboxStore();
  const text = (_a = useComboboxSelectors.text()) != null ? _a : "";
  const storeItems = useComboboxSelectors.items();
  const filter = (_c = (_b = activeComboboxStore.use).filter) == null ? void 0 : _c.call(_b);
  const sort = (_e = (_d = activeComboboxStore.use).sort) == null ? void 0 : _e.call(_d);
  const maxSuggestions = (_h = (_g = (_f = activeComboboxStore.use).maxSuggestions) == null ? void 0 : _g.call(_f)) != null ? _h : storeItems.length;
  React.useEffect(() => {
    items && comboboxActions.items(items);
  }, [items]);
  React.useEffect(() => {
    comboboxActions.filteredItems(
      storeItems.filter(
        filter ? filter(text) : (value) => value.text.toLowerCase().startsWith(text.toLowerCase())
      ).sort(sort == null ? void 0 : sort(text)).slice(0, maxSuggestions)
    );
  }, [filter, sort, storeItems, maxSuggestions, text]);
  return {
    combobox,
    targetRange
  };
};
var useComboboxContent = (state) => {
  const menuProps = state.combobox ? state.combobox.getMenuProps({}, { suppressRefError: true }) : { ref: null };
  return {
    menuProps,
    targetRange: state.targetRange
  };
};

// src/hooks/useComboboxControls.ts
import React2 from "react";
import { useCombobox } from "downshift";
var useComboboxControls = () => {
  const isOpen = useComboboxSelectors.isOpen();
  const highlightedIndex = useComboboxSelectors.highlightedIndex();
  const filteredItems = useComboboxSelectors.filteredItems();
  const {
    closeMenu,
    getComboboxProps,
    getInputProps,
    getItemProps,
    getMenuProps
  } = useCombobox({
    circularNavigation: true,
    highlightedIndex,
    isOpen,
    items: filteredItems
  });
  getMenuProps({}, { suppressRefError: true });
  getComboboxProps({}, { suppressRefError: true });
  getInputProps({}, { suppressRefError: true });
  return React2.useMemo(
    () => ({
      closeMenu,
      getItemProps,
      getMenuProps
    }),
    [closeMenu, getItemProps, getMenuProps]
  );
};

// src/hooks/useComboboxItem.tsx
import { useEditorRef } from "@udecode/plate-common";
var useComboboxItem = ({
  combobox,
  index,
  item,
  onRenderItem
}) => {
  var _a;
  const editor = useEditorRef();
  const text = (_a = useComboboxSelectors.text()) != null ? _a : "";
  const highlightedIndex = useComboboxSelectors.highlightedIndex();
  const Item = onRenderItem ? onRenderItem({ item, search: text }) : item.text;
  const highlighted = index === highlightedIndex;
  return {
    props: __spreadProps(__spreadValues({
      "data-highlighted": highlighted
    }, combobox.getItemProps({
      index,
      item
    })), {
      children: Item,
      onMouseDown: (e) => {
        var _a2;
        e.preventDefault();
        const onSelectItem = (_a2 = getComboboxStoreById(
          comboboxSelectors.activeId()
        )) == null ? void 0 : _a2.get.onSelectItem();
        onSelectItem == null ? void 0 : onSelectItem(editor, item);
      }
    })
  };
};
export {
  KEY_COMBOBOX,
  comboboxActions,
  comboboxSelectors,
  comboboxStore,
  createComboboxPlugin,
  getComboboxStoreById,
  getNextNonDisabledIndex,
  getNextWrappingIndex,
  getTextFromTrigger,
  onChangeCombobox,
  onKeyDownCombobox,
  useActiveComboboxStore,
  useComboboxContent,
  useComboboxContentState,
  useComboboxControls,
  useComboboxItem,
  useComboboxSelectors
};
//# sourceMappingURL=index.mjs.map