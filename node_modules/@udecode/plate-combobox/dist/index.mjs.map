{"version":3,"sources":["../src/combobox.store.ts","../src/createComboboxPlugin.ts","../src/onChangeCombobox.ts","../src/utils/getTextFromTrigger.ts","../src/onKeyDownCombobox.ts","../src/utils/getNextNonDisabledIndex.ts","../src/utils/getNextWrappingIndex.ts","../src/hooks/useComboboxContent.ts","../src/hooks/useComboboxControls.ts","../src/hooks/useComboboxItem.tsx"],"sourcesContent":["import type { Range } from 'slate';\n\nimport {\n  type ZustandStateActions,\n  type ZustandStoreApi,\n  createZustandStore,\n} from '@udecode/plate-common';\n\nimport type { ComboboxOnSelectItem, NoData, TComboboxItem } from './types';\n\nexport type ComboboxStateById<TData = NoData> = {\n  /** Is opening/closing the combobox controlled by the client. */\n  controlled?: boolean;\n\n  /**\n   * Items filter function by text.\n   *\n   * @default (value) => value.text.toLowerCase().startsWith(search.toLowerCase())\n   */\n  filter?: (search: string) => (item: TComboboxItem<TData>) => boolean;\n\n  /** Combobox id. */\n  id: string;\n\n  /**\n   * Max number of items.\n   *\n   * @default items.length\n   */\n  maxSuggestions?: number;\n\n  /** Called when an item is selected. */\n  onSelectItem: ComboboxOnSelectItem<TData> | null;\n\n  /** Regular expression for search, for example to allow whitespace */\n  searchPattern?: string;\n\n  /** Sort filtered items before applying maxSuggestions. */\n  sort?: (\n    search: string\n  ) => (a: TComboboxItem<TData>, b: TComboboxItem<TData>) => number;\n\n  /** Trigger that activates the combobox. */\n  trigger: string;\n};\n\nexport type ComboboxStoreById<TData = NoData> = ZustandStoreApi<\n  string,\n  ComboboxStateById<TData>,\n  ZustandStateActions<ComboboxStateById<TData>>\n>;\n\nexport type ComboboxState<TData = NoData> = {\n  /** Active id (combobox id which is opened). */\n  activeId: null | string;\n\n  /**\n   * Object whose keys are combobox ids and values are config stores (e.g. one\n   * for tag, one for mention,...).\n   */\n  byId: Record<string, ComboboxStoreById>;\n\n  /** Filtered items */\n  filteredItems: TComboboxItem<TData>[];\n\n  /** Highlighted index. */\n  highlightedIndex: number;\n\n  /** Unfiltered items. */\n  items: TComboboxItem<TData>[];\n\n  /** Range from the trigger to the cursor. */\n  targetRange: Range | null;\n\n  /** Text after the trigger. */\n  text: null | string;\n};\n\nconst createComboboxStore = (state: ComboboxStateById) =>\n  createZustandStore(`combobox-${state.id}`)(state);\n\nexport const comboboxStore = createZustandStore('combobox')<ComboboxState>({\n  activeId: null,\n  byId: {},\n  filteredItems: [],\n  highlightedIndex: 0,\n  items: [],\n  targetRange: null,\n  text: null,\n})\n  .extendActions((set, get) => ({\n    open: (state: Pick<ComboboxState, 'activeId' | 'targetRange' | 'text'>) => {\n      set.mergeState(state);\n    },\n    reset: () => {\n      set.state((draft) => {\n        draft.activeId = null;\n        draft.highlightedIndex = 0;\n        draft.filteredItems = [];\n        draft.items = [];\n        draft.text = null;\n        draft.targetRange = null;\n      });\n    },\n    setComboboxById: <TData = NoData>(state: ComboboxStateById<TData>) => {\n      if (get.byId()[state.id]) return;\n\n      set.state((draft) => {\n        draft.byId[state.id] = createComboboxStore(\n          state as unknown as ComboboxStateById\n        );\n      });\n    },\n  }))\n  .extendSelectors((state) => ({\n    isOpen: () => !!state.activeId,\n  }));\n\nexport const useComboboxSelectors = comboboxStore.use;\n\nexport const comboboxSelectors = comboboxStore.get;\n\nexport const comboboxActions = comboboxStore.set;\n\nexport const getComboboxStoreById = (id: null | string) =>\n  id ? comboboxSelectors.byId()[id] : null;\n\nexport const useActiveComboboxStore = () => {\n  const activeId = useComboboxSelectors.activeId();\n  const comboboxes = useComboboxSelectors.byId();\n\n  return activeId ? comboboxes[activeId] : null;\n};\n","import { createPluginFactory } from '@udecode/plate-common';\n\nimport { onChangeCombobox } from './onChangeCombobox';\nimport { onKeyDownCombobox } from './onKeyDownCombobox';\n\nexport const KEY_COMBOBOX = 'combobox';\n\nexport const createComboboxPlugin = createPluginFactory({\n  handlers: {\n    onChange: onChangeCombobox,\n    onKeyDown: onKeyDownCombobox,\n  },\n  key: KEY_COMBOBOX,\n});\n","import {\n  type PlateEditor,\n  type Value,\n  isCollapsed,\n} from '@udecode/plate-common';\nimport { Range } from 'slate';\n\nimport { comboboxActions, comboboxSelectors } from './combobox.store';\nimport { getTextFromTrigger } from './utils/getTextFromTrigger';\n\n/**\n * For each combobox state (byId):\n *\n * - If the selection is collapsed\n * - If the cursor follows the trigger\n * - If there is text without whitespaces after the trigger\n * - Open the combobox: set id, search, targetRange in the store Close the\n *   combobox if needed\n */\nexport const onChangeCombobox =\n  <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(\n    editor: E\n  ) =>\n  () => {\n    const byId = comboboxSelectors.byId();\n    const activeId = comboboxSelectors.activeId();\n\n    let shouldClose = true;\n\n    for (const store of Object.values(byId)) {\n      const id = store.get.id();\n      const controlled = store.get.controlled?.();\n\n      if (controlled) {\n        // do not close controlled comboboxes\n        if (activeId === id) {\n          shouldClose = false;\n\n          break;\n        } else {\n          // do not open controlled comboboxes\n          continue;\n        }\n      }\n\n      const { selection } = editor;\n\n      if (!selection || !isCollapsed(selection)) {\n        continue;\n      }\n\n      const trigger = store.get.trigger();\n      const searchPattern = store.get.searchPattern?.();\n\n      const isCursorAfterTrigger = getTextFromTrigger(editor, {\n        at: Range.start(selection),\n        searchPattern,\n        trigger,\n      });\n\n      if (!isCursorAfterTrigger) {\n        continue;\n      }\n\n      const { range, textAfterTrigger } = isCursorAfterTrigger;\n\n      comboboxActions.open({\n        activeId: id,\n        targetRange: range,\n        text: textAfterTrigger,\n      });\n\n      shouldClose = false;\n\n      break;\n    }\n\n    if (shouldClose && comboboxSelectors.isOpen()) {\n      comboboxActions.reset();\n    }\n  };\n","import type { Point } from 'slate';\n\nimport {\n  type TEditor,\n  type Value,\n  escapeRegExp,\n  getEditorString,\n  getPointBefore,\n  getRange,\n} from '@udecode/plate-common';\n\n/**\n * Get text and range from trigger to cursor. Starts with trigger and ends with\n * non-whitespace character.\n */\nexport const getTextFromTrigger = <V extends Value>(\n  editor: TEditor<V>,\n  {\n    at,\n    searchPattern = `\\\\S+`,\n    trigger,\n  }: { at: Point; searchPattern?: string; trigger: string }\n) => {\n  const escapedTrigger = escapeRegExp(trigger);\n  const triggerRegex = new RegExp(`(?:^|\\\\s)${escapedTrigger}`);\n\n  let start: Point | undefined = at;\n  let end: Point | undefined;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    end = start;\n\n    if (!start) break;\n\n    start = getPointBefore(editor, start);\n    const charRange = start && getRange(editor, start, end);\n    const charText = getEditorString(editor, charRange);\n\n    if (!charText.match(searchPattern)) {\n      start = end;\n\n      break;\n    }\n  }\n\n  // Range from start to cursor\n  const range = start && getRange(editor, start, at);\n  const text = getEditorString(editor, range);\n\n  if (!range || !text.match(triggerRegex)) return;\n\n  return {\n    range,\n    textAfterTrigger: text.slice(trigger.length),\n  };\n};\n\n// export const matchesTriggerAndPattern = (\n//   editor: TEditor<V>,\n//   { at, trigger, pattern }: { at: Point; trigger: string; pattern: string }\n// ) => {\n//   // Point at the start of line\n//   const lineStart = getPointBefore(editor, at, { unit: 'line' });\n//\n//   // Range from before to start\n//   const beforeRange = lineStart && getRange(editor, lineStart, at);\n//\n//   // Before text\n//   const beforeText = getEditorString(editor, beforeRange);\n//\n//   // Starts with char and ends with word characters\n//   const escapedTrigger = escapeRegExp(trigger);\n//\n//   const beforeRegex = new RegExp(`(?:^|\\\\s)${escapedTrigger}(${pattern})$`);\n//\n//   // Match regex on before text\n//   const match = !!beforeText && beforeText.match(beforeRegex);\n//\n//   // Point at the start of mention\n//   const mentionStart = match\n//     ? getPointBefore(editor, at, {\n//         unit: 'character',\n//         distance: match[1].length + trigger.length,\n//       })\n//     : null;\n//\n//   // Range from mention to start\n//   const mentionRange = mentionStart && getRange(editor, mentionStart, at);\n//\n//   return {\n//     range: mentionRange,\n//     match,\n//   };\n// };\n","import {\n  Hotkeys,\n  type KeyboardHandlerReturnType,\n  type PlateEditor,\n  type Value,\n  isHotkey,\n} from '@udecode/plate-common';\n\nimport {\n  comboboxActions,\n  comboboxSelectors,\n  getComboboxStoreById,\n} from './combobox.store';\nimport { getNextWrappingIndex } from './utils/getNextWrappingIndex';\n\n/**\n * If the combobox is open, handle:\n *\n * - Down (next item)\n * - Up (previous item)\n * - Escape (reset combobox)\n * - Tab, enter (select item)\n */\nexport const onKeyDownCombobox =\n  <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(\n    editor: E\n  ): KeyboardHandlerReturnType =>\n  (event) => {\n    const { activeId, filteredItems, highlightedIndex } =\n      comboboxSelectors.state();\n    const isOpen = comboboxSelectors.isOpen();\n\n    if (!isOpen) return;\n\n    const store = getComboboxStoreById(activeId);\n\n    if (!store) return;\n\n    const onSelectItem = store.get.onSelectItem();\n\n    if (isHotkey('down', event)) {\n      event.preventDefault();\n\n      const newIndex = getNextWrappingIndex(\n        1,\n        highlightedIndex,\n        filteredItems.length,\n        () => {},\n        true\n      );\n      comboboxActions.highlightedIndex(newIndex);\n\n      return;\n    }\n    if (isHotkey('up', event)) {\n      event.preventDefault();\n\n      const newIndex = getNextWrappingIndex(\n        -1,\n        highlightedIndex,\n        filteredItems.length,\n        () => {},\n        true\n      );\n      comboboxActions.highlightedIndex(newIndex);\n\n      return;\n    }\n    if (isHotkey('escape', event)) {\n      event.preventDefault();\n      comboboxActions.reset();\n\n      return;\n    }\n    if (Hotkeys.isTab(editor, event) || isHotkey('enter', event)) {\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (filteredItems[highlightedIndex]) {\n        onSelectItem?.(editor, filteredItems[highlightedIndex]);\n      }\n    }\n  };\n","/**\n * Returns the next index in the list of an item that is not disabled.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move\n *   backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index. Returns baseIndex if item is not disabled.\n *   Returns next non-disabled item otherwise. If no non-disabled found it will\n *   return -1.\n */\nexport const getNextNonDisabledIndex = (\n  moveAmount: number,\n  baseIndex: number,\n  itemCount: number,\n  getItemNodeFromIndex: any,\n  circular: boolean\n): number => {\n  const currentElementNode = getItemNodeFromIndex(baseIndex);\n\n  if (!currentElementNode?.hasAttribute('disabled')) {\n    return baseIndex;\n  }\n  if (moveAmount > 0) {\n    for (let index = baseIndex + 1; index < itemCount; index++) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  } else {\n    for (let index = baseIndex - 1; index >= 0; index--) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  }\n  if (circular) {\n    return moveAmount > 0\n      ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false)\n      : getNextNonDisabledIndex(\n          -1,\n          itemCount - 1,\n          itemCount,\n          getItemNodeFromIndex,\n          false\n        );\n  }\n\n  return -1;\n};\n","import { getNextNonDisabledIndex } from './getNextNonDisabledIndex';\n\n/**\n * Returns the new index in the list, in a circular way. If next value is out of\n * bonds from the total, it will wrap to either 0 or itemCount - 1.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move\n *   backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index after the move.\n */\nexport const getNextWrappingIndex = (\n  moveAmount: number,\n  baseIndex: number,\n  itemCount: number,\n  getItemNodeFromIndex: any,\n  circular = true\n) => {\n  if (itemCount === 0) {\n    return -1;\n  }\n\n  const itemsLastIndex = itemCount - 1;\n\n  // noinspection SuspiciousTypeOfGuard\n  if (\n    typeof baseIndex !== 'number' ||\n    baseIndex < 0 ||\n    baseIndex >= itemCount\n  ) {\n    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;\n  }\n\n  let newIndex = baseIndex + moveAmount;\n\n  if (newIndex < 0) {\n    newIndex = circular ? itemsLastIndex : 0;\n  } else if (newIndex > itemsLastIndex) {\n    newIndex = circular ? 0 : itemsLastIndex;\n  }\n\n  const nonDisabledNewIndex = getNextNonDisabledIndex(\n    moveAmount,\n    newIndex,\n    itemCount,\n    getItemNodeFromIndex,\n    circular\n  );\n\n  if (nonDisabledNewIndex === -1) {\n    return baseIndex >= itemCount ? -1 : baseIndex;\n  }\n\n  return nonDisabledNewIndex;\n};\n","import React from 'react';\n\nimport type { ComboboxProps } from '../types/ComboboxProps';\n\nimport {\n  type ComboboxControls,\n  type Data,\n  type NoData,\n  comboboxActions,\n  useActiveComboboxStore,\n  useComboboxSelectors,\n} from '..';\n\nexport type ComboboxContentProps<TData extends Data = NoData> = {\n  combobox: ComboboxControls;\n} & Omit<\n  ComboboxProps<TData>,\n  | 'controlled'\n  | 'filter'\n  | 'id'\n  | 'maxSuggestions'\n  | 'onSelectItem'\n  | 'searchPattern'\n  | 'sort'\n  | 'trigger'\n>;\n\nexport type ComboboxContentRootProps<TData extends Data = NoData> = {\n  combobox: ComboboxControls;\n} & ComboboxContentProps<TData>;\n\nexport const useComboboxContentState = <TData extends Data = NoData>({\n  combobox,\n  items,\n}: ComboboxContentRootProps<TData>) => {\n  const targetRange = useComboboxSelectors.targetRange();\n  const activeComboboxStore = useActiveComboboxStore()!;\n  const text = useComboboxSelectors.text() ?? '';\n  const storeItems = useComboboxSelectors.items();\n  const filter = activeComboboxStore.use.filter?.();\n  const sort = activeComboboxStore.use.sort?.();\n  const maxSuggestions =\n    activeComboboxStore.use.maxSuggestions?.() ?? storeItems.length;\n\n  // Update items\n  React.useEffect(() => {\n    items && comboboxActions.items(items);\n  }, [items]);\n\n  // Filter items\n  React.useEffect(() => {\n    comboboxActions.filteredItems(\n      storeItems\n        .filter(\n          filter\n            ? filter(text)\n            : (value) => value.text.toLowerCase().startsWith(text.toLowerCase())\n        )\n        .sort(sort?.(text))\n        .slice(0, maxSuggestions)\n    );\n  }, [filter, sort, storeItems, maxSuggestions, text]);\n\n  return {\n    combobox,\n    targetRange,\n  };\n};\n\nexport const useComboboxContent = (\n  state: ReturnType<typeof useComboboxContentState>\n) => {\n  const menuProps = state.combobox\n    ? state.combobox.getMenuProps({}, { suppressRefError: true })\n    : { ref: null };\n\n  return {\n    menuProps,\n    targetRange: state.targetRange,\n  };\n};\n","import React from 'react';\n\nimport { useCombobox } from 'downshift';\n\nimport { useComboboxSelectors } from '../combobox.store';\n\nexport type ComboboxControls = ReturnType<typeof useComboboxControls>;\n\nexport const useComboboxControls = () => {\n  const isOpen = useComboboxSelectors.isOpen();\n  const highlightedIndex = useComboboxSelectors.highlightedIndex();\n  const filteredItems = useComboboxSelectors.filteredItems();\n\n  const {\n    closeMenu,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getMenuProps,\n  } = useCombobox({\n    circularNavigation: true,\n    highlightedIndex,\n    isOpen,\n    items: filteredItems,\n  });\n  getMenuProps({}, { suppressRefError: true });\n  getComboboxProps({}, { suppressRefError: true });\n  getInputProps({}, { suppressRefError: true });\n\n  return React.useMemo(\n    () => ({\n      closeMenu,\n      getItemProps,\n      getMenuProps,\n    }),\n    [closeMenu, getItemProps, getMenuProps]\n  );\n};\n","import { useEditorRef } from '@udecode/plate-common';\n\nimport type { ComboboxContentProps } from './useComboboxContent';\n\nimport {\n  type ComboboxControls,\n  type Data,\n  type NoData,\n  type TComboboxItem,\n  comboboxSelectors,\n  getComboboxStoreById,\n  useComboboxSelectors,\n} from '..';\n\nexport type ComboboxContentItemProps<TData extends Data = NoData> = {\n  combobox: ComboboxControls;\n  index: number;\n  item: TComboboxItem<TData>;\n} & Pick<ComboboxContentProps<TData>, 'onRenderItem'>;\n\nexport interface ComboboxItemProps<TData extends Data = NoData> {\n  item: TComboboxItem<TData>;\n  search: string;\n}\n\nexport const useComboboxItem = <TData extends Data = NoData>({\n  combobox,\n  index,\n  item,\n  onRenderItem,\n}: ComboboxContentItemProps<TData>) => {\n  const editor = useEditorRef();\n  const text = useComboboxSelectors.text() ?? '';\n  const highlightedIndex = useComboboxSelectors.highlightedIndex();\n\n  const Item = onRenderItem\n    ? onRenderItem({ item: item as TComboboxItem<TData>, search: text })\n    : item.text;\n\n  const highlighted = index === highlightedIndex;\n\n  return {\n    props: {\n      'data-highlighted': highlighted,\n      ...combobox.getItemProps({\n        index,\n        item,\n      }),\n      children: Item,\n      onMouseDown: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        e.preventDefault();\n\n        const onSelectItem = getComboboxStoreById(\n          comboboxSelectors.activeId()\n        )?.get.onSelectItem();\n        onSelectItem?.(editor, item);\n      },\n    },\n  };\n};\n"],"mappings":"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","names":["React","React","_a"]}