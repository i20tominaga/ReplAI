import { TElement, TDescendant } from '@udecode/plate-common';
import * as zustand_x from 'zustand-x';
import * as slate from 'slate';
import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { KeyboardHandler, Value, PlateEditor, WithPlatePlugin } from '@udecode/plate-common/server';
import * as _udecode_slate from '@udecode/slate';
import React from 'react';
import { TextareaAutosizeProps } from 'react-textarea-autosize';

interface TCaptionElement extends TElement {
    caption?: TDescendant[];
}

declare const captionGlobalStore: zustand_x.StoreApi<"caption", {
    /** When defined, focus end of caption textarea with the same path. */
    focusEndCaptionPath: slate.Path | null;
    /** When defined, focus start of caption textarea with the same path. */
    focusStartCaptionPath: slate.Path | null;
}, zustand_x.StateActions<{
    /** When defined, focus end of caption textarea with the same path. */
    focusEndCaptionPath: slate.Path | null;
    /** When defined, focus start of caption textarea with the same path. */
    focusStartCaptionPath: slate.Path | null;
}>, {}>;

interface CaptionPlugin {
    /** Plugin keys to enable caption. */
    pluginKeys?: string[];
}
declare const KEY_CAPTION = "caption";
/** Enables support for caption. */
declare const createCaptionPlugin: <OP = CaptionPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const onKeyDownCaption: KeyboardHandler<CaptionPlugin>;

/** TODO: tests https://github.com/udecode/editor-protocol/issues/79 */
/**
 * Selection table:
 *
 * - If anchor is in table, focus in a block before: set focus to start of table
 * - If anchor is in table, focus in a block after: set focus to end of table
 * - If focus is in table, anchor in a block before: set focus to end of table
 * - If focus is in table, anchor in a block after: set focus to the point before
 *   start of table
 */
declare const withCaption: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { options }: WithPlatePlugin<CaptionPlugin, V, E>) => E;

interface CaptionOptions {
    readOnly?: boolean;
}
interface CaptionProps extends React.ComponentPropsWithoutRef<'figcaption'> {
    options?: CaptionOptions;
}
declare const useCaptionState: (options?: CaptionOptions) => {
    captionString: string;
    readOnly: boolean;
    selected: boolean;
};
declare const useCaption: (state: ReturnType<typeof useCaptionState>) => {
    hidden: boolean;
};
declare const Caption: React.ForwardRefExoticComponent<{
    as?: React.ElementType<any, keyof React.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: CaptionOptions | undefined;
    setProps?: ((hookProps: {}) => CaptionProps) | undefined;
    state?: {
        captionString: string;
        readOnly: boolean;
        selected: boolean;
    } | undefined;
    style?: React.CSSProperties | undefined;
} & CaptionProps & React.RefAttributes<any>>;

/** Focus textareaRef when focusCaptionPath is set to the image path. */
declare const useCaptionTextareaFocus: (textareaRef: React.RefObject<HTMLTextAreaElement>) => void;
declare const useCaptionTextareaState: () => {
    captionValue: string | number | readonly string[] | undefined;
    element: TCaptionElement;
    readOnly: boolean;
    setCaptionValue: React.Dispatch<React.SetStateAction<string | number | readonly string[] | undefined>>;
    textareaRef: React.RefObject<HTMLTextAreaElement>;
};
declare const useCaptionTextarea: ({ captionValue, element, readOnly, setCaptionValue, textareaRef, }: ReturnType<typeof useCaptionTextareaState>) => {
    props: {
        onChange: React.ChangeEventHandler<HTMLTextAreaElement>;
        onKeyDown: React.KeyboardEventHandler<HTMLTextAreaElement>;
        readOnly: boolean;
        value: string | number | readonly string[] | undefined;
    };
    ref: React.RefObject<HTMLTextAreaElement>;
};
declare const CaptionTextarea: React.ForwardRefExoticComponent<{
    as?: React.ElementType<any, keyof React.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: undefined;
    setProps?: ((hookProps: {
        onChange: React.ChangeEventHandler<HTMLTextAreaElement>;
        onKeyDown: React.KeyboardEventHandler<HTMLTextAreaElement>;
        readOnly: boolean;
        value: string | number | readonly string[] | undefined;
    }) => Omit<TextareaAutosizeProps & React.RefAttributes<HTMLTextAreaElement>, "ref">) | undefined;
    state?: {
        captionValue: string | number | readonly string[] | undefined;
        element: TCaptionElement;
        readOnly: boolean;
        setCaptionValue: React.Dispatch<React.SetStateAction<string | number | readonly string[] | undefined>>;
        textareaRef: React.RefObject<HTMLTextAreaElement>;
    } | undefined;
    style?: React.CSSProperties | undefined;
} & Omit<TextareaAutosizeProps & React.RefAttributes<HTMLTextAreaElement>, "ref"> & React.RefAttributes<any>>;

/**
 * `<textarea />` component for React which grows with content.
 *
 * @see https://github.com/Andarist/react-textarea-autosize
 * @see https://github.com/Andarist/react-textarea-autosize/issues/337
 */
declare const TextareaAutosize: React.ForwardRefExoticComponent<TextareaAutosizeProps & React.RefAttributes<HTMLTextAreaElement>>;

declare const useCaptionString: () => string;

export { Caption, type CaptionOptions, type CaptionPlugin, type CaptionProps, CaptionTextarea, KEY_CAPTION, type TCaptionElement, TextareaAutosize, captionGlobalStore, createCaptionPlugin, onKeyDownCaption, useCaption, useCaptionState, useCaptionString, useCaptionTextarea, useCaptionTextareaFocus, useCaptionTextareaState, withCaption };
