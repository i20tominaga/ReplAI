{"version":3,"sources":["../src/captionGlobalStore.ts","../src/createCaptionPlugin.ts","../src/onKeyDownCaption.ts","../src/withCaption.ts","../src/components/Caption.tsx","../src/hooks/useCaptionString.ts","../src/components/CaptionTextarea.tsx","../src/components/TextareaAutosize.tsx"],"sourcesContent":["import { type TPath, createZustandStore } from '@udecode/plate-common/server';\n\nexport const captionGlobalStore = createZustandStore('caption')({\n  /** When defined, focus end of caption textarea with the same path. */\n  focusEndCaptionPath: null as TPath | null,\n\n  /** When defined, focus start of caption textarea with the same path. */\n  focusStartCaptionPath: null as TPath | null,\n});\n","import { createPluginFactory } from '@udecode/plate-common/server';\n\nimport { onKeyDownCaption } from './onKeyDownCaption';\nimport { withCaption } from './withCaption';\n\nexport interface CaptionPlugin {\n  /** Plugin keys to enable caption. */\n  pluginKeys?: string[];\n}\n\nexport const KEY_CAPTION = 'caption';\n\n/** Enables support for caption. */\nexport const createCaptionPlugin = createPluginFactory<CaptionPlugin>({\n  handlers: {\n    onKeyDown: onKeyDownCaption,\n  },\n  key: KEY_CAPTION,\n  options: {\n    pluginKeys: [],\n  },\n  withOverrides: withCaption,\n});\n","import {\n  type KeyboardHandler,\n  getBlockAbove,\n  getPluginTypes,\n  isHotkey,\n} from '@udecode/plate-common/server';\n\nimport type { CaptionPlugin } from './createCaptionPlugin';\n\nimport { captionGlobalStore } from './captionGlobalStore';\n\nexport const onKeyDownCaption: KeyboardHandler<CaptionPlugin> =\n  (editor, { options }) =>\n  (e) => {\n    if (e.defaultPrevented) return;\n    // focus caption from image\n    if (isHotkey('down', e)) {\n      const types = getPluginTypes(editor, options.pluginKeys!);\n\n      const entry = getBlockAbove(editor, {\n        match: { type: types },\n      });\n\n      if (!entry) return;\n\n      captionGlobalStore.set.focusEndCaptionPath(entry[1]);\n    }\n  };\n","import type { Range } from 'slate';\n\nimport {\n  type PlateEditor,\n  type Value,\n  type WithPlatePlugin,\n  getAboveNode,\n  getNodeString,\n  getPluginTypes,\n  isCollapsed,\n  isHotkey,\n} from '@udecode/plate-common/server';\n\nimport type { CaptionPlugin } from './createCaptionPlugin';\n\nimport { captionGlobalStore } from './captionGlobalStore';\n\n/** TODO: tests https://github.com/udecode/editor-protocol/issues/79 */\n\n/**\n * Selection table:\n *\n * - If anchor is in table, focus in a block before: set focus to start of table\n * - If anchor is in table, focus in a block after: set focus to end of table\n * - If focus is in table, anchor in a block before: set focus to end of table\n * - If focus is in table, anchor in a block after: set focus to the point before\n *   start of table\n */\nexport const withCaption = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  { options }: WithPlatePlugin<CaptionPlugin, V, E>\n) => {\n  const { apply } = editor;\n\n  const { pluginKeys } = options;\n\n  editor.apply = (operation) => {\n    if (operation.type === 'set_selection') {\n      const newSelection = {\n        ...editor.selection,\n        ...operation.newProperties,\n      } as Range | null;\n\n      if (\n        editor.currentKeyboardEvent &&\n        isHotkey('up', editor.currentKeyboardEvent) &&\n        newSelection &&\n        isCollapsed(newSelection)\n      ) {\n        const types = getPluginTypes(editor, pluginKeys!);\n\n        const entry = getAboveNode(editor, {\n          at: newSelection,\n          match: { type: types },\n        });\n\n        if (entry) {\n          const [node] = entry;\n\n          if (\n            node.caption &&\n            getNodeString({ children: node.caption } as any).length > 0\n          ) {\n            setTimeout(() => {\n              captionGlobalStore.set.focusEndCaptionPath(entry[1]);\n            }, 0);\n          }\n        }\n      }\n    }\n\n    apply(operation);\n  };\n\n  return editor;\n};\n","import type React from 'react';\n\nimport { createPrimitiveComponent } from '@udecode/plate-common';\nimport { useReadOnly, useSelected } from 'slate-react';\n\nimport { useCaptionString } from '../hooks/useCaptionString';\n\nexport interface CaptionOptions {\n  readOnly?: boolean;\n}\n\nexport interface CaptionProps\n  extends React.ComponentPropsWithoutRef<'figcaption'> {\n  options?: CaptionOptions;\n}\n\nexport const useCaptionState = (options: CaptionOptions = {}) => {\n  const captionString = useCaptionString();\n\n  const selected = useSelected();\n  const _readOnly = useReadOnly();\n  const readOnly = options.readOnly || _readOnly;\n\n  return {\n    captionString,\n    readOnly,\n    selected,\n  };\n};\n\nexport const useCaption = (state: ReturnType<typeof useCaptionState>) => {\n  return {\n    hidden:\n      state.captionString.length === 0 && (state.readOnly || !state.selected),\n  };\n};\n\nexport const Caption = createPrimitiveComponent<'figcaption', CaptionProps>(\n  'figcaption'\n)({\n  propsHook: useCaption,\n  stateHook: useCaptionState,\n});\n","import React from 'react';\n\nimport { useElement } from '@udecode/plate-common';\nimport { getNodeString } from '@udecode/plate-common/server';\n\nimport type { TCaptionElement } from '../TCaptionElement';\n\nexport const useCaptionString = () => {\n  const { caption: nodeCaption = [{ children: [{ text: '' }] }] } =\n    useElement<TCaptionElement>();\n\n  return React.useMemo(() => {\n    return getNodeString(nodeCaption[0] as any) || '';\n  }, [nodeCaption]);\n};\n","import React from 'react';\n\nimport type { TextareaAutosizeProps } from 'react-textarea-autosize';\n\nimport {\n  createPrimitiveComponent,\n  findNodePath,\n  focusEditor,\n  useEditorRef,\n  useElement,\n} from '@udecode/plate-common';\nimport {\n  type TElement,\n  getNodeString,\n  getPointAfter,\n  isHotkey,\n  setNodes,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\nimport { useReadOnly } from 'slate-react';\n\nimport type { TCaptionElement } from '../TCaptionElement';\n\nimport { captionGlobalStore } from '../captionGlobalStore';\nimport { TextareaAutosize } from './TextareaAutosize';\n\n/** Focus textareaRef when focusCaptionPath is set to the image path. */\nexport const useCaptionTextareaFocus = (\n  textareaRef: React.RefObject<HTMLTextAreaElement>\n) => {\n  const editor = useEditorRef();\n  const element = useElement<TCaptionElement>();\n\n  const focusCaptionPath = captionGlobalStore.use.focusEndCaptionPath();\n\n  React.useEffect(() => {\n    if (focusCaptionPath && textareaRef.current) {\n      const path = findNodePath(editor, element);\n\n      if (path && Path.equals(path, focusCaptionPath)) {\n        textareaRef.current.focus();\n        captionGlobalStore.set.focusEndCaptionPath(null);\n      }\n    }\n  }, [editor, element, focusCaptionPath, textareaRef]);\n};\n\nexport const useCaptionTextareaState = () => {\n  const element = useElement<TCaptionElement>();\n\n  const {\n    caption: nodeCaption = [{ children: [{ text: '' }] }] as [TElement],\n  } = element;\n\n  const [captionValue, setCaptionValue] = React.useState<\n    TextareaAutosizeProps['value']\n  >(getNodeString(nodeCaption[0]));\n\n  const readOnly = useReadOnly();\n\n  const textareaRef = React.useRef<HTMLTextAreaElement>(null);\n\n  useCaptionTextareaFocus(textareaRef);\n\n  return {\n    captionValue,\n    element,\n    readOnly,\n    setCaptionValue,\n    textareaRef,\n  };\n};\n\nexport const useCaptionTextarea = ({\n  captionValue,\n  element,\n  readOnly,\n  setCaptionValue,\n  textareaRef,\n}: ReturnType<typeof useCaptionTextareaState>) => {\n  const editor = useEditorRef();\n\n  const onChange: TextareaAutosizeProps['onChange'] = React.useCallback(\n    (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n      const newValue = e.target.value;\n\n      // local state\n      setCaptionValue(newValue);\n\n      const path = findNodePath(editor, element);\n\n      if (!path) return;\n\n      // saved state\n      setNodes<TCaptionElement>(\n        editor,\n        { caption: [{ text: newValue }] },\n        { at: path }\n      );\n    },\n    [editor, element, setCaptionValue]\n  );\n\n  const onKeyDown: TextareaAutosizeProps['onKeyDown'] = (e) => {\n    // select image\n    if (isHotkey('up', e)) {\n      const path = findNodePath(editor, element);\n\n      if (!path) return;\n\n      e.preventDefault();\n\n      focusEditor(editor, path);\n    }\n    // select next block\n    if (isHotkey('down', e)) {\n      const path = findNodePath(editor, element);\n\n      if (!path) return;\n\n      const nextNodePath = getPointAfter(editor, path);\n\n      if (!nextNodePath) return;\n\n      e.preventDefault();\n\n      focusEditor(editor, nextNodePath);\n    }\n  };\n\n  return {\n    props: {\n      onChange,\n      onKeyDown,\n      readOnly,\n      value: captionValue,\n    },\n    ref: textareaRef,\n  };\n};\n\nexport const CaptionTextarea = createPrimitiveComponent(TextareaAutosize)({\n  propsHook: useCaptionTextarea,\n  stateHook: useCaptionTextareaState,\n});\n","import React from 'react';\nimport ReactTextareaAutosize, {\n  type TextareaAutosizeProps,\n} from 'react-textarea-autosize';\n\nimport { useIsomorphicLayoutEffect } from '@udecode/plate-common';\n\n/**\n * `<textarea />` component for React which grows with content.\n *\n * @see https://github.com/Andarist/react-textarea-autosize\n * @see https://github.com/Andarist/react-textarea-autosize/issues/337\n */\nconst TextareaAutosize = React.forwardRef<\n  HTMLTextAreaElement,\n  TextareaAutosizeProps\n>((props, ref) => {\n  const [isRerendered, setIsRerendered] = React.useState(false);\n\n  useIsomorphicLayoutEffect(() => setIsRerendered(true), []);\n\n  return isRerendered ? <ReactTextareaAutosize {...props} ref={ref} /> : null;\n});\nTextareaAutosize.displayName = 'TextareaAutosize';\n\nexport { TextareaAutosize };\n"],"mappings":"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","names":["getPluginTypes","isHotkey","isHotkey","getPluginTypes","getNodeString","React","createPrimitiveComponent","useElement","getNodeString","isHotkey","useReadOnly","React","React","useElement","React","getNodeString","useReadOnly","isHotkey","createPrimitiveComponent"]}