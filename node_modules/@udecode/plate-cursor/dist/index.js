"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CursorOverlay: () => CursorOverlay,
  CursorOverlayContent: () => CursorOverlayContent,
  FROZEN_EMPTY_ARRAY: () => FROZEN_EMPTY_ARRAY,
  getCaretPosition: () => getCaretPosition,
  getCursorOverlayState: () => getCursorOverlayState,
  getSelectionRects: () => getSelectionRects,
  useCursorOverlayPositions: () => useCursorOverlayPositions,
  useRefreshOnResize: () => useRefreshOnResize,
  useRequestReRender: () => useRequestReRender
});
module.exports = __toCommonJS(src_exports);

// src/components/CursorOverlay.tsx
var import_react4 = __toESM(require("react"));
var import_plate_common3 = require("@udecode/plate-common");

// src/hooks/useCursorOverlayPositions.ts
var import_react3 = __toESM(require("react"));
var import_plate_common2 = require("@udecode/plate-common");

// src/hooks/useRefreshOnResize.ts
var import_react2 = __toESM(require("react"));

// src/hooks/useRequestReRender.ts
var import_react = __toESM(require("react"));
var useRequestReRender = () => {
  const [, setUpdateCounter] = import_react.default.useState(0);
  const animationFrameRef = import_react.default.useRef(null);
  const requestReRender = import_react.default.useCallback((immediate = false) => {
    if (animationFrameRef.current && !immediate) {
      return;
    }
    if (!immediate) {
      animationFrameRef.current = requestAnimationFrame(() => {
        setUpdateCounter((state) => state + 1);
        animationFrameRef.current = null;
      });
      return;
    }
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = null;
    }
    setUpdateCounter((state) => state + 1);
  }, []);
  import_react.default.useEffect(() => {
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = null;
    }
  });
  import_react.default.useEffect(
    () => () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    },
    []
  );
  return requestReRender;
};

// src/hooks/useRefreshOnResize.ts
var useRefreshOnResize = ({
  containerRef,
  refreshOnResize,
  selectionRectCache
}) => {
  const requestReRender = useRequestReRender();
  const refresh = import_react2.default.useCallback(
    (sync = false) => {
      selectionRectCache.current = /* @__PURE__ */ new WeakMap();
      requestReRender(sync);
    },
    [requestReRender, selectionRectCache]
  );
  import_react2.default.useEffect(() => {
    if (!refreshOnResize || !(containerRef == null ? void 0 : containerRef.current)) {
      return;
    }
    const resizeObserver = new ResizeObserver(() => refresh());
    resizeObserver.observe(containerRef.current);
    return () => resizeObserver.disconnect();
  }, [containerRef, refresh, refreshOnResize]);
  return {
    refresh
  };
};

// src/queries/getCaretPosition.ts
var import_slate = require("slate");
var getCaretPosition = (selectionRects, range) => {
  const isCollapsed = range && import_slate.Range.isCollapsed(range);
  const isBackward = range && import_slate.Range.isBackward(range);
  const anchorRect = selectionRects[isBackward ? 0 : selectionRects.length - 1];
  if (!anchorRect) {
    return null;
  }
  return {
    height: anchorRect.height,
    left: anchorRect.left + (isBackward || isCollapsed ? 0 : anchorRect.width),
    top: anchorRect.top
  };
};

// src/queries/getCursorOverlayState.ts
var getCursorOverlayState = ({
  cursors: cursorStates,
  selectionRects
}) => {
  if (!cursorStates)
    return [];
  return Object.entries(cursorStates).map(([key, cursorState]) => {
    var _a, _b;
    const selection = (_a = cursorState == null ? void 0 : cursorState.selection) != null ? _a : null;
    const rects = (_b = selectionRects[key]) != null ? _b : FROZEN_EMPTY_ARRAY;
    const caretPosition = selection ? getCaretPosition(rects, selection) : null;
    return __spreadProps(__spreadValues({}, cursorState), {
      caretPosition,
      selection,
      selectionRects: rects
    });
  });
};

// src/queries/getSelectionRects.ts
var import_plate_common = require("@udecode/plate-common");
var import_server = require("@udecode/plate-common/server");
var import_slate2 = require("slate");
var getSelectionRects = (editor, {
  range,
  xOffset,
  yOffset
}) => {
  const [start, end] = import_slate2.Range.edges(range);
  const domRange = (0, import_plate_common.toDOMRange)(editor, range);
  if (!domRange) {
    return [];
  }
  const selectionRects = [];
  const textEntries = (0, import_server.getNodeEntries)(editor, {
    at: range,
    match: import_server.isText
  });
  for (const [textNode, textPath] of textEntries) {
    const domNode = (0, import_plate_common.toDOMNode)(editor, textNode);
    if (!(domNode == null ? void 0 : domNode.parentElement)) {
      return [];
    }
    const isStartNode = import_slate2.Path.equals(textPath, start.path);
    const isEndNode = import_slate2.Path.equals(textPath, end.path);
    let clientRects = null;
    if (isStartNode || isEndNode) {
      const nodeRange = document.createRange();
      nodeRange.selectNode(domNode);
      if (isStartNode) {
        nodeRange.setStart(domRange.startContainer, domRange.startOffset);
      }
      if (isEndNode) {
        nodeRange.setEnd(domRange.endContainer, domRange.endOffset);
      }
      clientRects = nodeRange.getClientRects();
    } else {
      clientRects = domNode.getClientRects();
    }
    for (let i = 0; i < clientRects.length; i++) {
      const clientRect = clientRects.item(i);
      if (!clientRect) {
        continue;
      }
      selectionRects.push({
        height: clientRect.height,
        left: clientRect.left - xOffset,
        top: clientRect.top - yOffset,
        width: clientRect.width
      });
    }
  }
  return selectionRects;
};

// src/hooks/useCursorOverlayPositions.ts
var FROZEN_EMPTY_ARRAY = Object.freeze(
  []
);
var useCursorOverlayPositions = ({
  containerRef,
  cursors: cursorStates,
  refreshOnResize = true
} = {}) => {
  const editor = (0, import_plate_common2.useEditorRef)();
  const selectionRectCache = import_react3.default.useRef(
    /* @__PURE__ */ new WeakMap()
  );
  const [selectionRects, setSelectionRects] = import_react3.default.useState({});
  const updateSelectionRects = import_react3.default.useCallback(() => {
    if (!(containerRef == null ? void 0 : containerRef.current))
      return;
    if (!cursorStates)
      return;
    let xOffset = 0;
    let yOffset = 0;
    if (containerRef) {
      const contentRect = containerRef.current.getBoundingClientRect();
      xOffset = contentRect.x;
      yOffset = contentRect.y;
    }
    let selectionRectsChanged = Object.keys(selectionRects).length !== Object.keys(cursorStates).length;
    const getCachedSelectionRects = ({
      cursor
    }) => {
      const range = cursor.selection;
      if (!range) {
        return FROZEN_EMPTY_ARRAY;
      }
      const cached = selectionRectCache.current.get(range);
      if (cached) {
        return cached;
      }
      const rects = getSelectionRects(editor, { range, xOffset, yOffset });
      selectionRectsChanged = true;
      selectionRectCache.current.set(range, rects);
      return rects;
    };
    const updated = Object.fromEntries(
      Object.entries(cursorStates).map(([key, cursor]) => [
        key,
        getCachedSelectionRects({
          cursor
        })
      ])
    );
    if (selectionRectsChanged) {
      setSelectionRects(updated);
    }
  }, [containerRef, cursorStates, editor, selectionRects]);
  (0, import_plate_common2.useIsomorphicLayoutEffect)(() => {
    updateSelectionRects();
  });
  const cursors = import_react3.default.useMemo(
    () => getCursorOverlayState({
      cursors: cursorStates,
      selectionRects
    }),
    [cursorStates, selectionRects]
  );
  const { refresh } = useRefreshOnResize({
    containerRef,
    refreshOnResize,
    selectionRectCache
  });
  return { cursors, refresh };
};

// src/components/CursorOverlay.tsx
function CursorOverlayContent(_a) {
  var _b = _a, {
    classNames,
    onRenderCaret,
    onRenderCursor: CursorComponent,
    onRenderSelectionRect
  } = _b, props = __objRest(_b, [
    "classNames",
    "onRenderCaret",
    "onRenderCursor",
    "onRenderSelectionRect"
  ]);
  const { disableCaret, disableSelection } = props;
  const { cursors } = useCursorOverlayPositions(props);
  const cursorProps = {
    classNames,
    disableCaret,
    disableSelection,
    onRenderCaret,
    onRenderSelectionRect
  };
  if (!CursorComponent)
    return null;
  return /* @__PURE__ */ import_react4.default.createElement(import_react4.default.Fragment, null, cursors.map((cursor) => /* @__PURE__ */ import_react4.default.createElement(CursorComponent, __spreadValues(__spreadValues({ key: cursor.key }, cursorProps), cursor))));
}
function CursorOverlay(props) {
  const isMounted = (0, import_plate_common3.usePlateSelectors)().isMounted();
  if (!isMounted)
    return null;
  return /* @__PURE__ */ import_react4.default.createElement(CursorOverlayContent, __spreadValues({}, props));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CursorOverlay,
  CursorOverlayContent,
  FROZEN_EMPTY_ARRAY,
  getCaretPosition,
  getCursorOverlayState,
  getSelectionRects,
  useCursorOverlayPositions,
  useRefreshOnResize,
  useRequestReRender
});
//# sourceMappingURL=index.js.map