// src/column-store.ts
import { findNodePath, useEditorRef, useElement } from "@udecode/plate-common";
import { setNodes as setNodes2 } from "@udecode/plate-common/server";

// src/createColumnPlugin.ts
import {
  createPluginFactory
} from "@udecode/plate-common/server";

// src/onKeyDownColumn.ts
import {
  getParentNode,
  isHotkey,
  select
} from "@udecode/plate-common/server";
var onKeyDownColumn = (editor) => (e) => {
  if (e.defaultPrevented)
    return;
  const at = editor.selection;
  if (isHotkey("mod+a", e) && at) {
    const selectionParent = getParentNode(editor, at);
    if (!selectionParent)
      return;
    const [, parentPath] = selectionParent;
    parentPath.pop();
    select(editor, parentPath);
    e.preventDefault();
    e.stopPropagation();
  }
};

// src/withColumn.ts
import {
  getAboveNode,
  isCollapsed,
  isElement as isElement3,
  isStartPoint
} from "@udecode/plate-common/server";

// src/normalizers/normalizedColumn.ts
import {
  createPathRef,
  getLastChildPath,
  isElement as isElement2
} from "@udecode/plate-common/server";

// src/transforms/insertColumnGroup.ts
import {
  ELEMENT_DEFAULT,
  insertNodes,
  withoutNormalizing
} from "@udecode/plate-common/server";
var insertColumnGroup = (editor) => {
  withoutNormalizing(editor, () => {
    insertNodes(editor, {
      children: [
        {
          children: [{ children: [{ text: "" }], type: ELEMENT_DEFAULT }],
          type: ELEMENT_COLUMN,
          width: "50%"
        },
        {
          children: [{ children: [{ text: "" }], type: ELEMENT_DEFAULT }],
          type: ELEMENT_COLUMN,
          width: "50%"
        }
      ],
      layout: [50, 50],
      type: ELEMENT_COLUMN_GROUP
    });
  });
};

// src/transforms/insertEmptyColumn.ts
import {
  ELEMENT_DEFAULT as ELEMENT_DEFAULT2,
  getQueryOptions,
  insertNodes as insertNodes2
} from "@udecode/plate-common/server";
var insertEmptyColumn = (editor, options) => {
  const width = (options == null ? void 0 : options.width) || "33%";
  insertNodes2(
    editor,
    {
      children: [{ children: [{ text: "" }], type: ELEMENT_DEFAULT2 }],
      type: ELEMENT_COLUMN,
      width
    },
    getQueryOptions(editor, options)
  );
};

// src/transforms/moveMiddleColumn.ts
import {
  moveNodes,
  removeNodes,
  unwrapNodes
} from "@udecode/plate-common/server";
import { Node } from "slate";
var moveMiddleColumn = (editor, [node, path], options) => {
  const direction = (options == null ? void 0 : options.direction) || "left";
  if (direction === "left") {
    const DESCENDANT_PATH = [1];
    const middleChildNode = Node.get(node, DESCENDANT_PATH);
    const isEmpty = editor.isEmpty(middleChildNode);
    const middleChildPathRef = editor.pathRef(path.concat(DESCENDANT_PATH));
    if (isEmpty) {
      removeNodes(editor, { at: middleChildPathRef.current });
      return false;
    }
    const firstNode = Node.descendant(node, [0]);
    const firstLast = path.concat([0, firstNode.children.length]);
    moveNodes(editor, { at: middleChildPathRef.current, to: firstLast });
    unwrapNodes(editor, { at: middleChildPathRef.current });
    middleChildPathRef.unref();
  }
};

// src/transforms/setColumnWidth.ts
import {
  getChildren,
  getNodeEntry,
  isElement,
  setNodes
} from "@udecode/plate-common/server";
var setColumnWidth = (editor, groupPathRef, layout) => {
  const path = groupPathRef.unref();
  const columnGroup = getNodeEntry(editor, path);
  if (!columnGroup)
    throw new Error(`can not find the column group in ${path}`);
  const children = getChildren(columnGroup);
  const childPaths = Array.from(children, (item) => item[1]);
  childPaths.forEach((item, index) => {
    const width = layout[index] + "%";
    if (!width)
      return;
    setNodes(
      editor,
      { width },
      {
        at: item,
        match: (n) => isElement(n) && n.type === ELEMENT_COLUMN
      }
    );
  });
};

// src/normalizers/normalizedColumn.ts
var normalizeColumn = (editor) => {
  const { normalizeNode } = editor;
  return function(entry) {
    if (isElement2(entry[0]) && entry[0].type === ELEMENT_COLUMN_GROUP) {
      return normalizeColumnHelper(
        editor,
        entry
      );
    }
    return normalizeNode(entry);
  };
};
var normalizeColumnHelper = (editor, entry) => {
  const [node, path] = entry;
  const prevChildrenCnt = node.children.length;
  const currentLayout = node.layout;
  if (!currentLayout)
    return;
  const currentChildrenCnt = currentLayout.length;
  const groupPathRef = createPathRef(editor, path);
  if (prevChildrenCnt === 2 && currentChildrenCnt === 3) {
    const lastChildPath = getLastChildPath(entry);
    insertEmptyColumn(editor, {
      at: lastChildPath
    });
    setColumnWidth(editor, groupPathRef, currentLayout);
  }
  if (prevChildrenCnt === 3 && currentChildrenCnt === 2) {
    moveMiddleColumn(editor, entry, { direction: "left" });
    setColumnWidth(editor, groupPathRef, currentLayout);
  }
  if (prevChildrenCnt === currentChildrenCnt) {
    setColumnWidth(editor, groupPathRef, currentLayout);
  }
};

// src/withColumn.ts
var withColumn = (editor) => {
  const { deleteBackward, isEmpty } = editor;
  editor.normalizeNode = normalizeColumn(editor);
  editor.deleteBackward = (unit) => {
    var _a;
    if (isCollapsed(editor.selection)) {
      const entry = getAboveNode(editor, {
        match: (n) => isElement3(n) && n.type === ELEMENT_COLUMN
      });
      if (entry) {
        const [node, path] = entry;
        if (node.children.length > 1)
          return deleteBackward(unit);
        const isStart = isStartPoint(editor, (_a = editor.selection) == null ? void 0 : _a.anchor, path);
        if (isStart)
          return;
      }
    }
    deleteBackward(unit);
  };
  editor.isEmpty = (element) => {
    if ((element == null ? void 0 : element.type) && element.type === ELEMENT_COLUMN) {
      return element.children.length === 1 && isEmpty(element.children[0]);
    }
    return isEmpty(element);
  };
  return editor;
};

// src/createColumnPlugin.ts
var ELEMENT_COLUMN_GROUP = "column_group";
var ELEMENT_COLUMN = "column";
var createColumnPlugin = createPluginFactory({
  handlers: {
    onKeyDown: onKeyDownColumn
  },
  isElement: true,
  key: ELEMENT_COLUMN_GROUP,
  options: {},
  plugins: [
    {
      isElement: true,
      key: ELEMENT_COLUMN,
      withOverrides: withColumn
    }
  ]
});

// src/column-store.ts
var useColumnState = () => {
  const editor = useEditorRef();
  const columnGroupElement = useElement(ELEMENT_COLUMN_GROUP);
  const columnPath = findNodePath(editor, columnGroupElement);
  const setDoubleColumn = () => {
    setNodes2(editor, { layout: [50, 50] }, { at: columnPath });
  };
  const setThreeColumn = () => {
    setNodes2(editor, { layout: [33, 33, 33] }, { at: columnPath });
  };
  const setRightSideDoubleColumn = () => {
    setNodes2(editor, { layout: [70, 30] }, { at: columnPath });
  };
  const setLeftSideDoubleColumn = () => {
    setNodes2(editor, { layout: [30, 70] }, { at: columnPath });
  };
  const setDoubleSideDoubleColumn = () => {
    setNodes2(editor, { layout: [25, 50, 25] }, { at: columnPath });
  };
  return {
    setDoubleColumn,
    setDoubleSideDoubleColumn,
    setLeftSideDoubleColumn,
    setRightSideDoubleColumn,
    setThreeColumn
  };
};

// src/hooks/useDebouncePopoverOpen.ts
import { useEditorSelector } from "@udecode/plate-common";
import { isCollapsed as isCollapsed2 } from "@udecode/plate-common/server";
import { useReadOnly, useSelected } from "slate-react";
var useDebouncePopoverOpen = () => {
  const readOnly = useReadOnly();
  const selected = useSelected();
  const selectionCollapsed = useEditorSelector(
    (editor) => isCollapsed2(editor.selection),
    []
  );
  return !readOnly && selected && selectionCollapsed;
};
export {
  ELEMENT_COLUMN,
  ELEMENT_COLUMN_GROUP,
  createColumnPlugin,
  insertColumnGroup,
  insertEmptyColumn,
  moveMiddleColumn,
  normalizeColumn,
  onKeyDownColumn,
  setColumnWidth,
  useColumnState,
  useDebouncePopoverOpen,
  withColumn
};
//# sourceMappingURL=index.mjs.map