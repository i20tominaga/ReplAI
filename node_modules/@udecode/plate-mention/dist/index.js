"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ELEMENT_MENTION: () => ELEMENT_MENTION,
  ELEMENT_MENTION_INPUT: () => ELEMENT_MENTION_INPUT,
  createMentionPlugin: () => createMentionPlugin,
  findMentionInput: () => findMentionInput,
  getMentionOnSelectItem: () => getMentionOnSelectItem,
  isNodeMentionInput: () => isNodeMentionInput,
  isSelectionInMentionInput: () => isSelectionInMentionInput,
  mentionOnKeyDownHandler: () => mentionOnKeyDownHandler,
  removeMentionInput: () => removeMentionInput,
  withMention: () => withMention
});
module.exports = __toCommonJS(src_exports);

// src/createMentionPlugin.ts
var import_plate_common6 = require("@udecode/plate-common");

// src/handlers/mentionOnKeyDownHandler.ts
var import_plate_common4 = require("@udecode/plate-common");

// src/queries/findMentionInput.ts
var import_plate_common = require("@udecode/plate-common");
var findMentionInput = (editor, options) => (0, import_plate_common.findNode)(editor, __spreadProps(__spreadValues({}, options), {
  match: { type: (0, import_plate_common.getPluginType)(editor, ELEMENT_MENTION_INPUT) }
}));

// src/queries/isNodeMentionInput.ts
var import_plate_common2 = require("@udecode/plate-common");
var isNodeMentionInput = (editor, node) => {
  return node.type === (0, import_plate_common2.getPluginType)(editor, ELEMENT_MENTION_INPUT);
};

// src/queries/isSelectionInMentionInput.ts
var isSelectionInMentionInput = (editor) => findMentionInput(editor) !== void 0;

// src/transforms/removeMentionInput.ts
var import_plate_common3 = require("@udecode/plate-common");
var removeMentionInput = (editor, path) => (0, import_plate_common3.withoutNormalizing)(editor, () => {
  const node = (0, import_plate_common3.getNode)(editor, path);
  if (!node)
    return;
  const { trigger } = node;
  const text = (0, import_plate_common3.getNodeString)(node);
  (0, import_plate_common3.replaceNode)(editor, {
    at: path,
    nodes: { text: `${trigger}${text}` }
  });
});

// src/handlers/mentionOnKeyDownHandler.ts
var mentionOnKeyDownHandler = (options) => (editor) => (event) => {
  if ((0, import_plate_common4.isHotkey)("escape", event)) {
    const currentMentionInput = findMentionInput(editor);
    if (currentMentionInput) {
      event.preventDefault();
      removeMentionInput(editor, currentMentionInput[1]);
      (0, import_plate_common4.moveSelection)(editor, { unit: "word" });
      return true;
    }
    return false;
  }
  return (0, import_plate_common4.moveSelectionByOffset)(editor, options)(event);
};

// src/withMention.ts
var import_plate_combobox = require("@udecode/plate-combobox");
var import_plate_common5 = require("@udecode/plate-common");
var import_slate = require("slate");
var withMention = (editor, {
  options: { id, inputCreation, query, trigger, triggerPreviousCharPattern }
}) => {
  const { type } = (0, import_plate_common5.getPlugin)(editor, ELEMENT_MENTION_INPUT);
  const {
    apply,
    deleteBackward,
    insertBreak,
    insertFragment,
    insertNode,
    insertText: insertText2,
    insertTextData
  } = editor;
  const stripNewLineAndTrim = (text) => {
    return text.split(/\r\n|\r|\n/).map((line) => line.trim()).join("");
  };
  editor.insertFragment = (fragment) => {
    const inMentionInput = findMentionInput(editor) !== void 0;
    if (!inMentionInput) {
      return insertFragment(fragment);
    }
    return insertText2(
      fragment.map((node) => stripNewLineAndTrim((0, import_plate_common5.getNodeString)(node))).join("")
    );
  };
  editor.insertTextData = (data) => {
    const inMentionInput = findMentionInput(editor) !== void 0;
    if (!inMentionInput) {
      return insertTextData(data);
    }
    const text = data.getData("text/plain");
    if (!text) {
      return false;
    }
    editor.insertText(stripNewLineAndTrim(text));
    return true;
  };
  editor.deleteBackward = (unit) => {
    const currentMentionInput = findMentionInput(editor);
    if (currentMentionInput && (0, import_plate_common5.getNodeString)(currentMentionInput[0]) === "") {
      removeMentionInput(editor, currentMentionInput[1]);
      return (0, import_plate_common5.moveSelection)(editor, { unit: "word" });
    }
    deleteBackward(unit);
  };
  editor.insertBreak = () => {
    if (isSelectionInMentionInput(editor)) {
      return;
    }
    insertBreak();
  };
  editor.insertText = (text) => {
    if (!editor.selection || text !== trigger || query && !query(editor) || isSelectionInMentionInput(editor)) {
      return insertText2(text);
    }
    const previousChar = (0, import_plate_common5.getEditorString)(
      editor,
      (0, import_plate_common5.getRange)(
        editor,
        editor.selection,
        (0, import_plate_common5.getPointBefore)(editor, editor.selection)
      )
    );
    const matchesPreviousCharPattern = triggerPreviousCharPattern == null ? void 0 : triggerPreviousCharPattern.test(previousChar);
    if (matchesPreviousCharPattern && text === trigger) {
      const data = {
        children: [{ text: "" }],
        trigger,
        type
      };
      if (inputCreation) {
        data[inputCreation.key] = inputCreation.value;
      }
      return insertNode(data);
    }
    return insertText2(text);
  };
  editor.apply = (operation) => {
    var _a, _b, _c, _d;
    apply(operation);
    if (operation.type === "insert_text" || operation.type === "remove_text") {
      const currentMentionInput = findMentionInput(editor);
      if (currentMentionInput) {
        import_plate_combobox.comboboxActions.text((0, import_plate_common5.getNodeString)(currentMentionInput[0]));
      }
    } else if (operation.type === "set_selection") {
      const previousMentionInputPath = import_slate.Range.isRange(operation.properties) ? (_a = findMentionInput(editor, { at: operation.properties })) == null ? void 0 : _a[1] : void 0;
      const currentMentionInputPath = import_slate.Range.isRange(operation.newProperties) ? (_b = findMentionInput(editor, { at: operation.newProperties })) == null ? void 0 : _b[1] : void 0;
      if (previousMentionInputPath && !currentMentionInputPath) {
        removeMentionInput(editor, previousMentionInputPath);
        (0, import_plate_common5.moveSelection)(editor, { unit: "word" });
      }
      if (currentMentionInputPath) {
        import_plate_combobox.comboboxActions.targetRange(editor.selection);
      }
    } else if (operation.type === "insert_node" && isNodeMentionInput(editor, operation.node)) {
      if (operation.node.trigger !== trigger) {
        return;
      }
      const text = (_d = (_c = operation.node.children[0]) == null ? void 0 : _c.text) != null ? _d : "";
      if (inputCreation === void 0 || operation.node[inputCreation.key] === inputCreation.value) {
        (0, import_plate_common5.setSelection)(editor, {
          anchor: { offset: text.length, path: operation.path.concat([0]) },
          focus: { offset: text.length, path: operation.path.concat([0]) }
        });
        import_plate_combobox.comboboxActions.open({
          activeId: id,
          targetRange: editor.selection,
          text
        });
      }
    } else if (operation.type === "remove_node" && isNodeMentionInput(editor, operation.node)) {
      if (operation.node.trigger !== trigger) {
        return;
      }
      import_plate_combobox.comboboxActions.reset();
    }
  };
  return editor;
};

// src/createMentionPlugin.ts
var ELEMENT_MENTION = "mention";
var ELEMENT_MENTION_INPUT = "mention_input";
var createMentionPlugin = (0, import_plate_common6.createPluginFactory)({
  handlers: {
    onBlur: (editor) => () => {
      (0, import_plate_common6.removeNodes)(editor, {
        at: [],
        match: (n) => n.type === ELEMENT_MENTION_INPUT
      });
    },
    onKeyDown: mentionOnKeyDownHandler({ query: isSelectionInMentionInput })
  },
  isElement: true,
  isInline: true,
  isMarkableVoid: true,
  isVoid: true,
  key: ELEMENT_MENTION,
  options: {
    createMentionNode: (item) => ({ value: item.text }),
    trigger: "@",
    triggerPreviousCharPattern: /^\s?$/
  },
  plugins: [
    {
      isElement: true,
      isInline: true,
      key: ELEMENT_MENTION_INPUT
    }
  ],
  then: (editor, { key }) => ({
    options: {
      id: key
    }
  }),
  withOverrides: withMention
});

// src/getMentionOnSelectItem.ts
var import_plate_combobox2 = require("@udecode/plate-combobox");
var import_plate_common7 = require("@udecode/plate-common");
var getMentionOnSelectItem = ({
  key = ELEMENT_MENTION
} = {}) => (editor, item) => {
  var _a;
  const targetRange = import_plate_combobox2.comboboxSelectors.targetRange();
  if (!targetRange)
    return;
  const {
    options: { createMentionNode, insertSpaceAfterMention },
    type
  } = (0, import_plate_common7.getPlugin)(editor, key);
  const pathAbove = (_a = (0, import_plate_common7.getBlockAbove)(editor)) == null ? void 0 : _a[1];
  const isBlockEnd = () => editor.selection && pathAbove && (0, import_plate_common7.isEndPoint)(editor, editor.selection.anchor, pathAbove);
  (0, import_plate_common7.withoutNormalizing)(editor, () => {
    var _a2;
    const props = createMentionNode(item, {
      search: (_a2 = import_plate_combobox2.comboboxSelectors.text()) != null ? _a2 : ""
    });
    (0, import_plate_common7.select)(editor, targetRange);
    (0, import_plate_common7.withoutMergingHistory)(
      editor,
      () => (0, import_plate_common7.removeNodes)(editor, {
        match: (node) => isNodeMentionInput(editor, node)
      })
    );
    (0, import_plate_common7.insertNodes)(editor, __spreadValues({
      children: [{ text: "" }],
      type
    }, props));
    (0, import_plate_common7.moveSelection)(editor, { unit: "offset" });
    if (isBlockEnd() && insertSpaceAfterMention) {
      (0, import_plate_common7.insertText)(editor, " ");
    }
  });
  return import_plate_combobox2.comboboxActions.reset();
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ELEMENT_MENTION,
  ELEMENT_MENTION_INPUT,
  createMentionPlugin,
  findMentionInput,
  getMentionOnSelectItem,
  isNodeMentionInput,
  isSelectionInMentionInput,
  mentionOnKeyDownHandler,
  removeMentionInput,
  withMention
});
//# sourceMappingURL=index.js.map