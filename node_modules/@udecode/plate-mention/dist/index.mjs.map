{"version":3,"sources":["../src/createMentionPlugin.ts","../src/handlers/mentionOnKeyDownHandler.ts","../src/queries/findMentionInput.ts","../src/queries/isNodeMentionInput.ts","../src/queries/isSelectionInMentionInput.ts","../src/transforms/removeMentionInput.ts","../src/withMention.ts","../src/getMentionOnSelectItem.ts"],"sourcesContent":["import { createPluginFactory, removeNodes } from '@udecode/plate-common';\n\nimport type { MentionPlugin } from './types';\n\nimport { mentionOnKeyDownHandler } from './handlers/mentionOnKeyDownHandler';\nimport { isSelectionInMentionInput } from './queries/index';\nimport { withMention } from './withMention';\n\nexport const ELEMENT_MENTION = 'mention';\n\nexport const ELEMENT_MENTION_INPUT = 'mention_input';\n\n/** Enables support for autocompleting @mentions. */\nexport const createMentionPlugin = createPluginFactory<MentionPlugin>({\n  handlers: {\n    onBlur: (editor) => () => {\n      // remove mention_input nodes from editor on blur\n      removeNodes(editor, {\n        at: [],\n        match: (n) => n.type === ELEMENT_MENTION_INPUT,\n      });\n    },\n    onKeyDown: mentionOnKeyDownHandler({ query: isSelectionInMentionInput }),\n  },\n  isElement: true,\n  isInline: true,\n  isMarkableVoid: true,\n  isVoid: true,\n  key: ELEMENT_MENTION,\n  options: {\n    createMentionNode: (item) => ({ value: item.text }),\n    trigger: '@',\n    triggerPreviousCharPattern: /^\\s?$/,\n  },\n  plugins: [\n    {\n      isElement: true,\n      isInline: true,\n      key: ELEMENT_MENTION_INPUT,\n    },\n  ],\n  then: (editor, { key }) => ({\n    options: {\n      id: key,\n    },\n  }),\n  withOverrides: withMention,\n});\n","import {\n  type KeyboardEventHandler,\n  type MoveSelectionByOffsetOptions,\n  type PlateEditor,\n  type Value,\n  isHotkey,\n  moveSelection,\n  moveSelectionByOffset,\n} from '@udecode/plate-common';\n\nimport { findMentionInput } from '../queries/index';\nimport { removeMentionInput } from '../transforms/index';\n\nexport const mentionOnKeyDownHandler: <V extends Value>(\n  options?: MoveSelectionByOffsetOptions<V>\n) => (editor: PlateEditor<V>) => KeyboardEventHandler =\n  (options) => (editor) => (event) => {\n    if (isHotkey('escape', event)) {\n      const currentMentionInput = findMentionInput(editor)!;\n\n      if (currentMentionInput) {\n        event.preventDefault();\n        removeMentionInput(editor, currentMentionInput[1]);\n        moveSelection(editor, { unit: 'word' });\n\n        return true;\n      }\n\n      return false;\n    }\n\n    return moveSelectionByOffset(editor, options)(event);\n  };\n","import {\n  type FindNodeOptions,\n  type PlateEditor,\n  type Value,\n  findNode,\n  getPluginType,\n} from '@udecode/plate-common';\n\nimport type { TMentionInputElement } from '../types';\n\nimport { ELEMENT_MENTION_INPUT } from '../createMentionPlugin';\n\nexport const findMentionInput = <V extends Value>(\n  editor: PlateEditor<V>,\n  options?: Omit<FindNodeOptions<V>, 'match'>\n) =>\n  findNode<TMentionInputElement>(editor, {\n    ...options,\n    match: { type: getPluginType(editor, ELEMENT_MENTION_INPUT) },\n  });\n","import {\n  type PlateEditor,\n  type TNode,\n  type Value,\n  getPluginType,\n} from '@udecode/plate-common';\n\nimport type { TMentionInputElement } from '../types';\n\nimport { ELEMENT_MENTION_INPUT } from '../createMentionPlugin';\n\nexport const isNodeMentionInput = <V extends Value>(\n  editor: PlateEditor<V>,\n  node: TNode\n): node is TMentionInputElement => {\n  return node.type === getPluginType(editor, ELEMENT_MENTION_INPUT);\n};\n","import type { PlateEditor, Value } from '@udecode/plate-common';\n\nimport { findMentionInput } from './findMentionInput';\n\nexport const isSelectionInMentionInput = <V extends Value>(\n  editor: PlateEditor<V>\n) => findMentionInput(editor) !== undefined;\n","import type { Path } from 'slate';\n\nimport {\n  type EText,\n  type PlateEditor,\n  type Value,\n  getNode,\n  getNodeString,\n  replaceNode,\n  withoutNormalizing,\n} from '@udecode/plate-common';\n\nimport type { TMentionInputElement } from '../types';\n\nexport const removeMentionInput = <V extends Value>(\n  editor: PlateEditor<V>,\n  path: Path\n) =>\n  withoutNormalizing(editor, () => {\n    const node = getNode<TMentionInputElement>(editor, path);\n\n    if (!node) return;\n\n    const { trigger } = node;\n\n    const text = getNodeString(node);\n\n    replaceNode(editor, {\n      at: path,\n      nodes: { text: `${trigger}${text}` } as EText<V>,\n    });\n  });\n","import { comboboxActions } from '@udecode/plate-combobox';\nimport {\n  type PlateEditor,\n  type TNode,\n  type TText,\n  type Value,\n  type WithPlatePlugin,\n  getEditorString,\n  getNodeString,\n  getPlugin,\n  getPointBefore,\n  getRange,\n  moveSelection,\n  setSelection,\n} from '@udecode/plate-common';\nimport { Range } from 'slate';\n\nimport type { MentionPlugin, TMentionInputElement } from './types';\n\nimport { ELEMENT_MENTION_INPUT } from './createMentionPlugin';\nimport {\n  findMentionInput,\n  isNodeMentionInput,\n  isSelectionInMentionInput,\n} from './queries/index';\nimport { removeMentionInput } from './transforms/removeMentionInput';\n\nexport const withMention = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  {\n    options: { id, inputCreation, query, trigger, triggerPreviousCharPattern },\n  }: WithPlatePlugin<MentionPlugin, V, E>\n) => {\n  const { type } = getPlugin<{}, V>(editor, ELEMENT_MENTION_INPUT);\n\n  const {\n    apply,\n    deleteBackward,\n    insertBreak,\n    insertFragment,\n    insertNode,\n    insertText,\n    insertTextData,\n  } = editor;\n\n  const stripNewLineAndTrim: (text: string) => string = (text) => {\n    return text\n      .split(/\\r\\n|\\r|\\n/)\n      .map((line) => line.trim())\n      .join('');\n  };\n\n  editor.insertFragment = (fragment) => {\n    const inMentionInput = findMentionInput(editor) !== undefined;\n\n    if (!inMentionInput) {\n      return insertFragment(fragment);\n    }\n\n    return insertText(\n      fragment.map((node) => stripNewLineAndTrim(getNodeString(node))).join('')\n    );\n  };\n\n  editor.insertTextData = (data) => {\n    const inMentionInput = findMentionInput(editor) !== undefined;\n\n    if (!inMentionInput) {\n      return insertTextData(data);\n    }\n\n    const text = data.getData('text/plain');\n\n    if (!text) {\n      return false;\n    }\n\n    editor.insertText(stripNewLineAndTrim(text));\n\n    return true;\n  };\n\n  editor.deleteBackward = (unit) => {\n    const currentMentionInput = findMentionInput(editor);\n\n    if (currentMentionInput && getNodeString(currentMentionInput[0]) === '') {\n      removeMentionInput(editor, currentMentionInput[1]);\n\n      return moveSelection(editor, { unit: 'word' });\n    }\n\n    deleteBackward(unit);\n  };\n\n  editor.insertBreak = () => {\n    if (isSelectionInMentionInput(editor)) {\n      return;\n    }\n\n    insertBreak();\n  };\n\n  editor.insertText = (text) => {\n    if (\n      !editor.selection ||\n      text !== trigger ||\n      (query && !query(editor as PlateEditor)) ||\n      isSelectionInMentionInput(editor)\n    ) {\n      return insertText(text);\n    }\n\n    // Make sure a mention input is created at the beginning of line or after a whitespace\n    const previousChar = getEditorString(\n      editor,\n      getRange(\n        editor,\n        editor.selection,\n        getPointBefore(editor, editor.selection)\n      )\n    );\n    const matchesPreviousCharPattern =\n      triggerPreviousCharPattern?.test(previousChar);\n\n    if (matchesPreviousCharPattern && text === trigger) {\n      const data: TMentionInputElement = {\n        children: [{ text: '' }],\n        trigger,\n        type,\n      };\n\n      if (inputCreation) {\n        data[inputCreation.key] = inputCreation.value;\n      }\n\n      return insertNode(data);\n    }\n\n    return insertText(text);\n  };\n\n  editor.apply = (operation) => {\n    apply(operation);\n\n    if (operation.type === 'insert_text' || operation.type === 'remove_text') {\n      const currentMentionInput = findMentionInput(editor);\n\n      if (currentMentionInput) {\n        comboboxActions.text(getNodeString(currentMentionInput[0]));\n      }\n    } else if (operation.type === 'set_selection') {\n      const previousMentionInputPath = Range.isRange(operation.properties)\n        ? findMentionInput(editor, { at: operation.properties })?.[1]\n        : undefined;\n\n      const currentMentionInputPath = Range.isRange(operation.newProperties)\n        ? findMentionInput(editor, { at: operation.newProperties })?.[1]\n        : undefined;\n\n      if (previousMentionInputPath && !currentMentionInputPath) {\n        removeMentionInput(editor, previousMentionInputPath);\n        moveSelection(editor, { unit: 'word' });\n      }\n      if (currentMentionInputPath) {\n        comboboxActions.targetRange(editor.selection);\n      }\n    } else if (\n      operation.type === 'insert_node' &&\n      isNodeMentionInput(editor, operation.node as TNode)\n    ) {\n      if ((operation.node as TMentionInputElement).trigger !== trigger) {\n        return;\n      }\n\n      const text =\n        ((operation.node as TMentionInputElement).children as TText[])[0]\n          ?.text ?? '';\n\n      if (\n        inputCreation === undefined ||\n        operation.node[inputCreation.key] === inputCreation.value\n      ) {\n        // Needed for undo - after an undo a mention insert we only receive\n        // an insert_node with the mention input, i.e. nothing indicating that it\n        // was an undo.\n        setSelection(editor, {\n          anchor: { offset: text.length, path: operation.path.concat([0]) },\n          focus: { offset: text.length, path: operation.path.concat([0]) },\n        });\n\n        comboboxActions.open({\n          activeId: id!,\n          targetRange: editor.selection,\n          text,\n        });\n      }\n    } else if (\n      operation.type === 'remove_node' &&\n      isNodeMentionInput(editor, operation.node as TNode)\n    ) {\n      if ((operation.node as TMentionInputElement).trigger !== trigger) {\n        return;\n      }\n\n      comboboxActions.reset();\n    }\n  };\n\n  return editor;\n};\n","import {\n  type ComboboxOnSelectItem,\n  type Data,\n  type NoData,\n  type TComboboxItem,\n  comboboxActions,\n  comboboxSelectors,\n} from '@udecode/plate-combobox';\nimport {\n  type PlatePluginKey,\n  type TNodeProps,\n  getBlockAbove,\n  getPlugin,\n  insertNodes,\n  insertText,\n  isEndPoint,\n  moveSelection,\n  removeNodes,\n  select,\n  withoutMergingHistory,\n  withoutNormalizing,\n} from '@udecode/plate-common';\n\nimport type { MentionPlugin, TMentionElement } from './types';\n\nimport { ELEMENT_MENTION } from './createMentionPlugin';\nimport { isNodeMentionInput } from './queries/isNodeMentionInput';\n\nexport type CreateMentionNode<TData extends Data> = (\n  item: TComboboxItem<TData>,\n  meta: CreateMentionNodeMeta\n) => TNodeProps<TMentionElement>;\n\nexport interface CreateMentionNodeMeta {\n  search: string;\n}\n\nexport const getMentionOnSelectItem =\n  <TData extends Data = NoData>({\n    key = ELEMENT_MENTION,\n  }: PlatePluginKey = {}): ComboboxOnSelectItem<TData> =>\n  (editor, item) => {\n    const targetRange = comboboxSelectors.targetRange();\n\n    if (!targetRange) return;\n\n    const {\n      options: { createMentionNode, insertSpaceAfterMention },\n      type,\n    } = getPlugin<MentionPlugin>(editor as any, key);\n\n    const pathAbove = getBlockAbove(editor)?.[1];\n    const isBlockEnd = () =>\n      editor.selection &&\n      pathAbove &&\n      isEndPoint(editor, editor.selection.anchor, pathAbove);\n\n    withoutNormalizing(editor, () => {\n      // Selectors are sensitive to operations, it's better to create everything\n      // before the editor state is changed. For example, asking for text after\n      // removeNodes below will return null.\n      const props = createMentionNode!(item, {\n        search: comboboxSelectors.text() ?? '',\n      });\n\n      select(editor, targetRange);\n\n      withoutMergingHistory(editor, () =>\n        removeNodes(editor, {\n          match: (node) => isNodeMentionInput(editor, node),\n        })\n      );\n\n      insertNodes<TMentionElement>(editor, {\n        children: [{ text: '' }],\n        type,\n        ...props,\n      } as TMentionElement);\n\n      // move the selection after the element\n      moveSelection(editor, { unit: 'offset' });\n\n      if (isBlockEnd() && insertSpaceAfterMention) {\n        insertText(editor, ' ');\n      }\n    });\n\n    return comboboxActions.reset();\n  };\n"],"mappings":"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","names":["getPluginType","getPluginType","getNodeString","moveSelection","insertText","getNodeString","moveSelection","comboboxActions","getPlugin","moveSelection","removeNodes","withoutNormalizing","getPlugin","withoutNormalizing","_a","removeNodes","moveSelection","comboboxActions"]}