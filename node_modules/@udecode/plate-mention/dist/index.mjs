var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/createMentionPlugin.ts
import { createPluginFactory, removeNodes } from "@udecode/plate-common";

// src/handlers/mentionOnKeyDownHandler.ts
import {
  isHotkey,
  moveSelection,
  moveSelectionByOffset
} from "@udecode/plate-common";

// src/queries/findMentionInput.ts
import {
  findNode,
  getPluginType
} from "@udecode/plate-common";
var findMentionInput = (editor, options) => findNode(editor, __spreadProps(__spreadValues({}, options), {
  match: { type: getPluginType(editor, ELEMENT_MENTION_INPUT) }
}));

// src/queries/isNodeMentionInput.ts
import {
  getPluginType as getPluginType2
} from "@udecode/plate-common";
var isNodeMentionInput = (editor, node) => {
  return node.type === getPluginType2(editor, ELEMENT_MENTION_INPUT);
};

// src/queries/isSelectionInMentionInput.ts
var isSelectionInMentionInput = (editor) => findMentionInput(editor) !== void 0;

// src/transforms/removeMentionInput.ts
import {
  getNode,
  getNodeString,
  replaceNode,
  withoutNormalizing
} from "@udecode/plate-common";
var removeMentionInput = (editor, path) => withoutNormalizing(editor, () => {
  const node = getNode(editor, path);
  if (!node)
    return;
  const { trigger } = node;
  const text = getNodeString(node);
  replaceNode(editor, {
    at: path,
    nodes: { text: `${trigger}${text}` }
  });
});

// src/handlers/mentionOnKeyDownHandler.ts
var mentionOnKeyDownHandler = (options) => (editor) => (event) => {
  if (isHotkey("escape", event)) {
    const currentMentionInput = findMentionInput(editor);
    if (currentMentionInput) {
      event.preventDefault();
      removeMentionInput(editor, currentMentionInput[1]);
      moveSelection(editor, { unit: "word" });
      return true;
    }
    return false;
  }
  return moveSelectionByOffset(editor, options)(event);
};

// src/withMention.ts
import { comboboxActions } from "@udecode/plate-combobox";
import {
  getEditorString,
  getNodeString as getNodeString2,
  getPlugin,
  getPointBefore,
  getRange,
  moveSelection as moveSelection2,
  setSelection
} from "@udecode/plate-common";
import { Range } from "slate";
var withMention = (editor, {
  options: { id, inputCreation, query, trigger, triggerPreviousCharPattern }
}) => {
  const { type } = getPlugin(editor, ELEMENT_MENTION_INPUT);
  const {
    apply,
    deleteBackward,
    insertBreak,
    insertFragment,
    insertNode,
    insertText: insertText2,
    insertTextData
  } = editor;
  const stripNewLineAndTrim = (text) => {
    return text.split(/\r\n|\r|\n/).map((line) => line.trim()).join("");
  };
  editor.insertFragment = (fragment) => {
    const inMentionInput = findMentionInput(editor) !== void 0;
    if (!inMentionInput) {
      return insertFragment(fragment);
    }
    return insertText2(
      fragment.map((node) => stripNewLineAndTrim(getNodeString2(node))).join("")
    );
  };
  editor.insertTextData = (data) => {
    const inMentionInput = findMentionInput(editor) !== void 0;
    if (!inMentionInput) {
      return insertTextData(data);
    }
    const text = data.getData("text/plain");
    if (!text) {
      return false;
    }
    editor.insertText(stripNewLineAndTrim(text));
    return true;
  };
  editor.deleteBackward = (unit) => {
    const currentMentionInput = findMentionInput(editor);
    if (currentMentionInput && getNodeString2(currentMentionInput[0]) === "") {
      removeMentionInput(editor, currentMentionInput[1]);
      return moveSelection2(editor, { unit: "word" });
    }
    deleteBackward(unit);
  };
  editor.insertBreak = () => {
    if (isSelectionInMentionInput(editor)) {
      return;
    }
    insertBreak();
  };
  editor.insertText = (text) => {
    if (!editor.selection || text !== trigger || query && !query(editor) || isSelectionInMentionInput(editor)) {
      return insertText2(text);
    }
    const previousChar = getEditorString(
      editor,
      getRange(
        editor,
        editor.selection,
        getPointBefore(editor, editor.selection)
      )
    );
    const matchesPreviousCharPattern = triggerPreviousCharPattern == null ? void 0 : triggerPreviousCharPattern.test(previousChar);
    if (matchesPreviousCharPattern && text === trigger) {
      const data = {
        children: [{ text: "" }],
        trigger,
        type
      };
      if (inputCreation) {
        data[inputCreation.key] = inputCreation.value;
      }
      return insertNode(data);
    }
    return insertText2(text);
  };
  editor.apply = (operation) => {
    var _a, _b, _c, _d;
    apply(operation);
    if (operation.type === "insert_text" || operation.type === "remove_text") {
      const currentMentionInput = findMentionInput(editor);
      if (currentMentionInput) {
        comboboxActions.text(getNodeString2(currentMentionInput[0]));
      }
    } else if (operation.type === "set_selection") {
      const previousMentionInputPath = Range.isRange(operation.properties) ? (_a = findMentionInput(editor, { at: operation.properties })) == null ? void 0 : _a[1] : void 0;
      const currentMentionInputPath = Range.isRange(operation.newProperties) ? (_b = findMentionInput(editor, { at: operation.newProperties })) == null ? void 0 : _b[1] : void 0;
      if (previousMentionInputPath && !currentMentionInputPath) {
        removeMentionInput(editor, previousMentionInputPath);
        moveSelection2(editor, { unit: "word" });
      }
      if (currentMentionInputPath) {
        comboboxActions.targetRange(editor.selection);
      }
    } else if (operation.type === "insert_node" && isNodeMentionInput(editor, operation.node)) {
      if (operation.node.trigger !== trigger) {
        return;
      }
      const text = (_d = (_c = operation.node.children[0]) == null ? void 0 : _c.text) != null ? _d : "";
      if (inputCreation === void 0 || operation.node[inputCreation.key] === inputCreation.value) {
        setSelection(editor, {
          anchor: { offset: text.length, path: operation.path.concat([0]) },
          focus: { offset: text.length, path: operation.path.concat([0]) }
        });
        comboboxActions.open({
          activeId: id,
          targetRange: editor.selection,
          text
        });
      }
    } else if (operation.type === "remove_node" && isNodeMentionInput(editor, operation.node)) {
      if (operation.node.trigger !== trigger) {
        return;
      }
      comboboxActions.reset();
    }
  };
  return editor;
};

// src/createMentionPlugin.ts
var ELEMENT_MENTION = "mention";
var ELEMENT_MENTION_INPUT = "mention_input";
var createMentionPlugin = createPluginFactory({
  handlers: {
    onBlur: (editor) => () => {
      removeNodes(editor, {
        at: [],
        match: (n) => n.type === ELEMENT_MENTION_INPUT
      });
    },
    onKeyDown: mentionOnKeyDownHandler({ query: isSelectionInMentionInput })
  },
  isElement: true,
  isInline: true,
  isMarkableVoid: true,
  isVoid: true,
  key: ELEMENT_MENTION,
  options: {
    createMentionNode: (item) => ({ value: item.text }),
    trigger: "@",
    triggerPreviousCharPattern: /^\s?$/
  },
  plugins: [
    {
      isElement: true,
      isInline: true,
      key: ELEMENT_MENTION_INPUT
    }
  ],
  then: (editor, { key }) => ({
    options: {
      id: key
    }
  }),
  withOverrides: withMention
});

// src/getMentionOnSelectItem.ts
import {
  comboboxActions as comboboxActions2,
  comboboxSelectors
} from "@udecode/plate-combobox";
import {
  getBlockAbove,
  getPlugin as getPlugin2,
  insertNodes,
  insertText,
  isEndPoint,
  moveSelection as moveSelection3,
  removeNodes as removeNodes2,
  select,
  withoutMergingHistory,
  withoutNormalizing as withoutNormalizing2
} from "@udecode/plate-common";
var getMentionOnSelectItem = ({
  key = ELEMENT_MENTION
} = {}) => (editor, item) => {
  var _a;
  const targetRange = comboboxSelectors.targetRange();
  if (!targetRange)
    return;
  const {
    options: { createMentionNode, insertSpaceAfterMention },
    type
  } = getPlugin2(editor, key);
  const pathAbove = (_a = getBlockAbove(editor)) == null ? void 0 : _a[1];
  const isBlockEnd = () => editor.selection && pathAbove && isEndPoint(editor, editor.selection.anchor, pathAbove);
  withoutNormalizing2(editor, () => {
    var _a2;
    const props = createMentionNode(item, {
      search: (_a2 = comboboxSelectors.text()) != null ? _a2 : ""
    });
    select(editor, targetRange);
    withoutMergingHistory(
      editor,
      () => removeNodes2(editor, {
        match: (node) => isNodeMentionInput(editor, node)
      })
    );
    insertNodes(editor, __spreadValues({
      children: [{ text: "" }],
      type
    }, props));
    moveSelection3(editor, { unit: "offset" });
    if (isBlockEnd() && insertSpaceAfterMention) {
      insertText(editor, " ");
    }
  });
  return comboboxActions2.reset();
};
export {
  ELEMENT_MENTION,
  ELEMENT_MENTION_INPUT,
  createMentionPlugin,
  findMentionInput,
  getMentionOnSelectItem,
  isNodeMentionInput,
  isSelectionInMentionInput,
  mentionOnKeyDownHandler,
  removeMentionInput,
  withMention
};
//# sourceMappingURL=index.mjs.map